// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT
#![allow(deprecated)]

use crate::{Block,Drive,Job,Loop,Manager,Partition,PartitionTable,PartitionTypeInfo};
#[cfg(feature = "v2_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
use crate::{MDRaid};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "UDisksClient")]
    pub struct Client(Object<ffi::UDisksClient>);

    match fn {
        type_ => || ffi::udisks_client_get_type(),
    }
}

impl Client {
    //#[doc(alias = "udisks_client_new_sync")]
    //pub fn new_sync(cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> Client {
    //    unsafe { TODO: call ffi:udisks_client_new_sync() }
    //}

    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    #[doc(alias = "udisks_client_get_all_blocks_for_mdraid")]
    #[doc(alias = "get_all_blocks_for_mdraid")]
    pub fn all_blocks_for_mdraid(&self, raid: &impl IsA<MDRaid>) -> Vec<Block> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_client_get_all_blocks_for_mdraid(self.to_glib_none().0, raid.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_block_for_dev")]
    #[doc(alias = "get_block_for_dev")]
    pub fn block_for_dev(&self, block_device_number: u64) -> Option<Block> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_block_for_dev(self.to_glib_none().0, block_device_number))
        }
    }

    #[doc(alias = "udisks_client_get_block_for_drive")]
    #[doc(alias = "get_block_for_drive")]
    pub fn block_for_drive(&self, drive: &impl IsA<Drive>, get_physical: bool) -> Option<Block> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_block_for_drive(self.to_glib_none().0, drive.as_ref().to_glib_none().0, get_physical.into_glib()))
        }
    }

    #[doc(alias = "udisks_client_get_block_for_label")]
    #[doc(alias = "get_block_for_label")]
    pub fn block_for_label(&self, label: &str) -> Vec<Block> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_client_get_block_for_label(self.to_glib_none().0, label.to_glib_none().0))
        }
    }

    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    #[doc(alias = "udisks_client_get_block_for_mdraid")]
    #[doc(alias = "get_block_for_mdraid")]
    pub fn block_for_mdraid(&self, raid: &impl IsA<MDRaid>) -> Option<Block> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_block_for_mdraid(self.to_glib_none().0, raid.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_block_for_uuid")]
    #[doc(alias = "get_block_for_uuid")]
    pub fn block_for_uuid(&self, uuid: &str) -> Vec<Block> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_client_get_block_for_uuid(self.to_glib_none().0, uuid.to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_cleartext_block")]
    #[doc(alias = "get_cleartext_block")]
    pub fn cleartext_block(&self, block: &impl IsA<Block>) -> Option<Block> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_cleartext_block(self.to_glib_none().0, block.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_drive_for_block")]
    #[doc(alias = "get_drive_for_block")]
    pub fn drive_for_block(&self, block: &impl IsA<Block>) -> Option<Drive> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_drive_for_block(self.to_glib_none().0, block.as_ref().to_glib_none().0))
        }
    }

    //#[cfg_attr(feature = "v2_1", deprecated = "Since 2.1")]
    //#[allow(deprecated)]
    //#[doc(alias = "udisks_client_get_drive_info")]
    //#[doc(alias = "get_drive_info")]
    //pub fn drive_info(&self, drive: &impl IsA<Drive>, out_drive_icon: /*Ignored*/gio::Icon, out_media_icon: /*Ignored*/gio::Icon) -> (glib::GString, glib::GString, glib::GString) {
    //    unsafe { TODO: call ffi:udisks_client_get_drive_info() }
    //}

    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    #[doc(alias = "udisks_client_get_drive_siblings")]
    #[doc(alias = "get_drive_siblings")]
    pub fn drive_siblings(&self, drive: &impl IsA<Drive>) -> Vec<Drive> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_client_get_drive_siblings(self.to_glib_none().0, drive.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_id_for_display")]
    #[doc(alias = "get_id_for_display")]
    pub fn id_for_display(&self, usage: &str, type_: &str, version: &str, long_string: bool) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_id_for_display(self.to_glib_none().0, usage.to_glib_none().0, type_.to_glib_none().0, version.to_glib_none().0, long_string.into_glib()))
        }
    }

    #[doc(alias = "udisks_client_get_job_description")]
    #[doc(alias = "get_job_description")]
    pub fn job_description(&self, job: &impl IsA<Job>) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_job_description(self.to_glib_none().0, job.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "udisks_client_get_jobs_for_object")]
    //#[doc(alias = "get_jobs_for_object")]
    //pub fn jobs_for_object(&self, object: /*Ignored*/&Object) -> Vec<Job> {
    //    unsafe { TODO: call ffi:udisks_client_get_jobs_for_object() }
    //}

    #[doc(alias = "udisks_client_get_loop_for_block")]
    #[doc(alias = "get_loop_for_block")]
    pub fn loop_for_block(&self, block: &impl IsA<Block>) -> Option<Loop> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_loop_for_block(self.to_glib_none().0, block.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_manager")]
    #[doc(alias = "get_manager")]
    pub fn manager(&self) -> Option<Manager> {
        unsafe {
            from_glib_none(ffi::udisks_client_get_manager(self.to_glib_none().0))
        }
    }

    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    #[doc(alias = "udisks_client_get_mdraid_for_block")]
    #[doc(alias = "get_mdraid_for_block")]
    pub fn mdraid_for_block(&self, block: &impl IsA<Block>) -> Option<MDRaid> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_mdraid_for_block(self.to_glib_none().0, block.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    #[doc(alias = "udisks_client_get_members_for_mdraid")]
    #[doc(alias = "get_members_for_mdraid")]
    pub fn members_for_mdraid(&self, raid: &impl IsA<MDRaid>) -> Vec<Block> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_client_get_members_for_mdraid(self.to_glib_none().0, raid.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "udisks_client_get_object")]
    //#[doc(alias = "get_object")]
    //pub fn object(&self, object_path: &str) -> /*Ignored*/Option<Object> {
    //    unsafe { TODO: call ffi:udisks_client_get_object() }
    //}

    //#[cfg(feature = "v2_1")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    //#[doc(alias = "udisks_client_get_object_info")]
    //#[doc(alias = "get_object_info")]
    //pub fn object_info(&self, object: /*Ignored*/&Object) -> Option<ObjectInfo> {
    //    unsafe { TODO: call ffi:udisks_client_get_object_info() }
    //}

    //#[doc(alias = "udisks_client_get_object_manager")]
    //#[doc(alias = "get_object_manager")]
    //pub fn object_manager(&self) -> /*Ignored*/Option<gio::DBusObjectManager> {
    //    unsafe { TODO: call ffi:udisks_client_get_object_manager() }
    //}

    #[doc(alias = "udisks_client_get_partition_info")]
    #[doc(alias = "get_partition_info")]
    pub fn partition_info(&self, partition: &impl IsA<Partition>) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_partition_info(self.to_glib_none().0, partition.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_partition_table")]
    #[doc(alias = "get_partition_table")]
    pub fn partition_table(&self, partition: &impl IsA<Partition>) -> Option<PartitionTable> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_partition_table(self.to_glib_none().0, partition.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_partition_table_subtype_for_display")]
    #[doc(alias = "get_partition_table_subtype_for_display")]
    pub fn partition_table_subtype_for_display(&self, partition_table_type: &str, partition_table_subtype: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_client_get_partition_table_subtype_for_display(self.to_glib_none().0, partition_table_type.to_glib_none().0, partition_table_subtype.to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_partition_table_subtypes")]
    #[doc(alias = "get_partition_table_subtypes")]
    pub fn partition_table_subtypes(&self, partition_table_type: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::udisks_client_get_partition_table_subtypes(self.to_glib_none().0, partition_table_type.to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_partition_table_type_for_display")]
    #[doc(alias = "get_partition_table_type_for_display")]
    pub fn partition_table_type_for_display(&self, partition_table_type: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_client_get_partition_table_type_for_display(self.to_glib_none().0, partition_table_type.to_glib_none().0))
        }
    }

    #[cfg(feature = "v2_1_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_1")))]
    #[doc(alias = "udisks_client_get_partition_type_and_subtype_for_display")]
    #[doc(alias = "get_partition_type_and_subtype_for_display")]
    pub fn partition_type_and_subtype_for_display(&self, partition_table_type: &str, partition_table_subtype: &str, partition_type: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_client_get_partition_type_and_subtype_for_display(self.to_glib_none().0, partition_table_type.to_glib_none().0, partition_table_subtype.to_glib_none().0, partition_type.to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_partition_type_for_display")]
    #[doc(alias = "get_partition_type_for_display")]
    pub fn partition_type_for_display(&self, partition_table_type: &str, partition_type: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_client_get_partition_type_for_display(self.to_glib_none().0, partition_table_type.to_glib_none().0, partition_type.to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_partition_type_infos")]
    #[doc(alias = "get_partition_type_infos")]
    pub fn partition_type_infos(&self, partition_table_type: &str, partition_table_subtype: Option<&str>) -> Vec<PartitionTypeInfo> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_client_get_partition_type_infos(self.to_glib_none().0, partition_table_type.to_glib_none().0, partition_table_subtype.to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_partitions")]
    #[doc(alias = "get_partitions")]
    pub fn partitions(&self, table: &impl IsA<PartitionTable>) -> Vec<Partition> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_client_get_partitions(self.to_glib_none().0, table.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_client_get_size_for_display")]
    #[doc(alias = "get_size_for_display")]
    pub fn size_for_display(&self, size: u64, use_pow2: bool, long_string: bool) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_client_get_size_for_display(self.to_glib_none().0, size, use_pow2.into_glib(), long_string.into_glib()))
        }
    }

    //#[doc(alias = "udisks_client_peek_object")]
    //pub fn peek_object(&self, object_path: &str) -> /*Ignored*/Option<Object> {
    //    unsafe { TODO: call ffi:udisks_client_peek_object() }
    //}

    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    #[doc(alias = "udisks_client_queue_changed")]
    pub fn queue_changed(&self) {
        unsafe {
            ffi::udisks_client_queue_changed(self.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_client_settle")]
    pub fn settle(&self) {
        unsafe {
            ffi::udisks_client_settle(self.to_glib_none().0);
        }
    }

    //#[cfg(feature = "v2_9")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    //#[doc(alias = "bus-connection")]
    //pub fn bus_connection(&self) -> /*Ignored*/Option<gio::DBusConnection> {
    //    ObjectExt::property(self, "bus-connection")
    //}

    #[doc(alias = "udisks_client_get_job_description_from_operation")]
    #[doc(alias = "get_job_description_from_operation")]
    pub fn job_description_from_operation(operation: &str) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::udisks_client_get_job_description_from_operation(operation.to_glib_none().0))
        }
    }

    //#[doc(alias = "udisks_client_new")]
    //pub fn new<P: FnOnce(Result<Client, /*Ignored*/glib::Error>) + 'static>(cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_client_new() }
    //}

    //
    //pub fn new_future() -> Pin<Box_<dyn std::future::Future<Output = Result<Client, /*Ignored*/glib::Error>> + 'static>> {

        //skip_assert_initialized!();
        //Box_::pin(gio::GioFuture::new(&(), move |_obj, cancellable, send| {
        //    Self::new(
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[cfg(feature = "v2_9")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    //#[doc(alias = "udisks_client_new_for_connection")]
    //pub fn new_for_connection<P: FnOnce(Result<Client, /*Ignored*/glib::Error>) + 'static>(connection: /*Ignored*/Option<&gio::DBusConnection>, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_client_new_for_connection() }
    //}

    //
    //#[cfg(feature = "v2_9")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    //pub fn new_for_connection_future(connection: /*Ignored*/Option<&gio::DBusConnection>) -> Pin<Box_<dyn std::future::Future<Output = Result<Client, /*Ignored*/glib::Error>> + 'static>> {

        //skip_assert_initialized!();
        //let connection = connection.map(ToOwned::to_owned);
        //Box_::pin(gio::GioFuture::new(&(), move |_obj, cancellable, send| {
        //    Self::new_for_connection(
        //        connection.as_ref().map(::std::borrow::Borrow::borrow),
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    #[doc(alias = "changed")]
    pub fn connect_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn changed_trampoline<F: Fn(&Client) + 'static>(this: *mut ffi::UDisksClient, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"changed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "manager")]
    pub fn connect_manager_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_manager_trampoline<F: Fn(&Client) + 'static>(this: *mut ffi::UDisksClient, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::manager\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_manager_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "object-manager")]
    pub fn connect_object_manager_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_object_manager_trampoline<F: Fn(&Client) + 'static>(this: *mut ffi::UDisksClient, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::object-manager\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_object_manager_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}
