// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{Block,BlockLVM2,Drive,DriveAta,Encrypted,Filesystem,Job,LogicalVolume,Loop,MDRaid,Manager,ManagerLVM2,Partition,PartitionTable,PhysicalVolume,Swapspace,VolumeGroup};
#[cfg(feature = "v2_1_3")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
use crate::{FilesystemBTRFS,ManagerBTRFS};
#[cfg(feature = "v2_9")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
use crate::{VDOVolume};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "UDisksObjectSkeleton")]
    pub struct ObjectSkeleton(Object<ffi::UDisksObjectSkeleton, ffi::UDisksObjectSkeletonClass>);

    match fn {
        type_ => || ffi::udisks_object_skeleton_get_type(),
    }
}

impl ObjectSkeleton {
        pub const NONE: Option<&'static ObjectSkeleton> = None;
    

    #[doc(alias = "udisks_object_skeleton_new")]
    pub fn new(object_path: &str) -> ObjectSkeleton {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::udisks_object_skeleton_new(object_path.to_glib_none().0))
        }
    }
}

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::ObjectSkeleton>> Sealed for T {}
}

pub trait ObjectSkeletonExt: IsA<ObjectSkeleton> + sealed::Sealed + 'static {
    #[doc(alias = "udisks_object_skeleton_set_block")]
    fn set_block(&self, interface_: Option<&impl IsA<Block>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_block(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_block_lvm2")]
    fn set_block_lvm2(&self, interface_: Option<&impl IsA<BlockLVM2>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_block_lvm2(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_drive")]
    fn set_drive(&self, interface_: Option<&impl IsA<Drive>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_drive(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_drive_ata")]
    fn set_drive_ata(&self, interface_: Option<&impl IsA<DriveAta>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_drive_ata(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_encrypted")]
    fn set_encrypted(&self, interface_: Option<&impl IsA<Encrypted>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_encrypted(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_filesystem")]
    fn set_filesystem(&self, interface_: Option<&impl IsA<Filesystem>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_filesystem(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    #[doc(alias = "udisks_object_skeleton_set_filesystem_btrfs")]
    fn set_filesystem_btrfs(&self, interface_: Option<&impl IsA<FilesystemBTRFS>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_filesystem_btrfs(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_job")]
    fn set_job(&self, interface_: Option<&impl IsA<Job>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_job(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_logical_volume")]
    fn set_logical_volume(&self, interface_: Option<&impl IsA<LogicalVolume>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_logical_volume(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_loop")]
    fn set_loop(&self, interface_: Option<&impl IsA<Loop>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_loop(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_manager")]
    fn set_manager(&self, interface_: Option<&impl IsA<Manager>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_manager(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    #[doc(alias = "udisks_object_skeleton_set_manager_btrfs")]
    fn set_manager_btrfs(&self, interface_: Option<&impl IsA<ManagerBTRFS>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_manager_btrfs(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_manager_lvm2")]
    fn set_manager_lvm2(&self, interface_: Option<&impl IsA<ManagerLVM2>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_manager_lvm2(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_mdraid")]
    fn set_mdraid(&self, interface_: Option<&impl IsA<MDRaid>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_mdraid(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_partition")]
    fn set_partition(&self, interface_: Option<&impl IsA<Partition>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_partition(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_partition_table")]
    fn set_partition_table(&self, interface_: Option<&impl IsA<PartitionTable>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_partition_table(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_physical_volume")]
    fn set_physical_volume(&self, interface_: Option<&impl IsA<PhysicalVolume>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_physical_volume(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_swapspace")]
    fn set_swapspace(&self, interface_: Option<&impl IsA<Swapspace>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_swapspace(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    #[doc(alias = "udisks_object_skeleton_set_vdo_volume")]
    fn set_vdo_volume(&self, interface_: Option<&impl IsA<VDOVolume>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_vdo_volume(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_object_skeleton_set_volume_group")]
    fn set_volume_group(&self, interface_: Option<&impl IsA<VolumeGroup>>) {
        unsafe {
            ffi::udisks_object_skeleton_set_volume_group(self.as_ref().to_glib_none().0, interface_.map(|p| p.as_ref()).to_glib_none().0);
        }
    }
}

impl<O: IsA<ObjectSkeleton>> ObjectSkeletonExt for O {}
