// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "UDisksDriveAta")]
    pub struct DriveAta(Interface<ffi::UDisksDriveAta, ffi::UDisksDriveAtaIface>);

    match fn {
        type_ => || ffi::udisks_drive_ata_get_type(),
    }
}

impl DriveAta {
        pub const NONE: Option<&'static DriveAta> = None;
    

    //#[doc(alias = "udisks_drive_ata_interface_info")]
    //pub fn interface_info() -> /*Ignored*/Option<gio::DBusInterfaceInfo> {
    //    unsafe { TODO: call ffi:udisks_drive_ata_interface_info() }
    //}

    //#[doc(alias = "udisks_drive_ata_override_properties")]
    //pub fn override_properties(klass: /*Ignored*/&mut glib::ObjectClass, property_id_begin: u32) -> u32 {
    //    unsafe { TODO: call ffi:udisks_drive_ata_override_properties() }
    //}
}

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::DriveAta>> Sealed for T {}
}

pub trait DriveAtaExt: IsA<DriveAta> + sealed::Sealed + 'static {
    //#[doc(alias = "udisks_drive_ata_call_pm_get_state")]
    //fn call_pm_get_state<P: FnOnce(Result<u8, /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_pm_get_state() }
    //}

    //
    //fn call_pm_get_state_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<u8, /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_pm_get_state(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_pm_get_state_sync")]
    //fn call_pm_get_state_sync(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> Result<(u8), glib::Error> {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_pm_get_state_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_call_pm_standby")]
    //fn call_pm_standby<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_pm_standby() }
    //}

    //
    //fn call_pm_standby_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_pm_standby(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_pm_standby_sync")]
    //fn call_pm_standby_sync(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_pm_standby_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_call_pm_wakeup")]
    //fn call_pm_wakeup<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_pm_wakeup() }
    //}

    //
    //fn call_pm_wakeup_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_pm_wakeup(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_pm_wakeup_sync")]
    //fn call_pm_wakeup_sync(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_pm_wakeup_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_call_security_erase_unit")]
    //fn call_security_erase_unit<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_security_erase_unit() }
    //}

    //
    //fn call_security_erase_unit_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_security_erase_unit(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_security_erase_unit_sync")]
    //fn call_security_erase_unit_sync(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_security_erase_unit_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_get_attributes")]
    //fn call_smart_get_attributes<P: FnOnce(Result</*Ignored*/glib::Variant, /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_get_attributes() }
    //}

    //
    //fn call_smart_get_attributes_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result</*Ignored*/glib::Variant, /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_smart_get_attributes(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_get_attributes_sync")]
    //fn call_smart_get_attributes_sync(&self, arg_options: /*Ignored*/&glib::Variant, out_attributes: /*Ignored*/glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_get_attributes_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_selftest_abort")]
    //fn call_smart_selftest_abort<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_selftest_abort() }
    //}

    //
    //fn call_smart_selftest_abort_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_smart_selftest_abort(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_selftest_abort_sync")]
    //fn call_smart_selftest_abort_sync(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_selftest_abort_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_selftest_start")]
    //fn call_smart_selftest_start<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_type: &str, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_selftest_start() }
    //}

    //
    //fn call_smart_selftest_start_future(&self, arg_type: &str, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_type = String::from(arg_type);
        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_smart_selftest_start(
        //        &arg_type,
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_selftest_start_sync")]
    //fn call_smart_selftest_start_sync(&self, arg_type: &str, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_selftest_start_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_set_enabled")]
    //fn call_smart_set_enabled<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_value: bool, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_set_enabled() }
    //}

    //
    //fn call_smart_set_enabled_future(&self, arg_value: bool, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_smart_set_enabled(
        //        arg_value,
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_set_enabled_sync")]
    //fn call_smart_set_enabled_sync(&self, arg_value: bool, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_set_enabled_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_update")]
    //fn call_smart_update<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_update() }
    //}

    //
    //fn call_smart_update_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_smart_update(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_drive_ata_call_smart_update_sync")]
    //fn call_smart_update_sync(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_drive_ata_call_smart_update_sync() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_pm_get_state")]
    //fn complete_pm_get_state(&self, invocation: /*Ignored*/gio::DBusMethodInvocation, state: u8) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_pm_get_state() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_pm_standby")]
    //fn complete_pm_standby(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_pm_standby() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_pm_wakeup")]
    //fn complete_pm_wakeup(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_pm_wakeup() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_security_erase_unit")]
    //fn complete_security_erase_unit(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_security_erase_unit() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_smart_get_attributes")]
    //fn complete_smart_get_attributes(&self, invocation: /*Ignored*/gio::DBusMethodInvocation, attributes: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_smart_get_attributes() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_smart_selftest_abort")]
    //fn complete_smart_selftest_abort(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_smart_selftest_abort() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_smart_selftest_start")]
    //fn complete_smart_selftest_start(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_smart_selftest_start() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_smart_set_enabled")]
    //fn complete_smart_set_enabled(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_smart_set_enabled() }
    //}

    //#[doc(alias = "udisks_drive_ata_complete_smart_update")]
    //fn complete_smart_update(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_drive_ata_complete_smart_update() }
    //}

    #[doc(alias = "udisks_drive_ata_dup_smart_selftest_status")]
    fn dup_smart_selftest_status(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_drive_ata_dup_smart_selftest_status(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_aam_enabled")]
    #[doc(alias = "get_aam_enabled")]
    fn is_aam_enabled(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_aam_enabled(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_aam_supported")]
    #[doc(alias = "get_aam_supported")]
    fn is_aam_supported(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_aam_supported(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_aam_vendor_recommended_value")]
    #[doc(alias = "get_aam_vendor_recommended_value")]
    fn aam_vendor_recommended_value(&self) -> i32 {
        unsafe {
            ffi::udisks_drive_ata_get_aam_vendor_recommended_value(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_apm_enabled")]
    #[doc(alias = "get_apm_enabled")]
    fn is_apm_enabled(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_apm_enabled(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_apm_supported")]
    #[doc(alias = "get_apm_supported")]
    fn is_apm_supported(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_apm_supported(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_pm_enabled")]
    #[doc(alias = "get_pm_enabled")]
    fn is_pm_enabled(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_pm_enabled(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_pm_supported")]
    #[doc(alias = "get_pm_supported")]
    fn is_pm_supported(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_pm_supported(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    #[doc(alias = "udisks_drive_ata_get_read_lookahead_enabled")]
    #[doc(alias = "get_read_lookahead_enabled")]
    fn is_read_lookahead_enabled(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_read_lookahead_enabled(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    #[doc(alias = "udisks_drive_ata_get_read_lookahead_supported")]
    #[doc(alias = "get_read_lookahead_supported")]
    fn is_read_lookahead_supported(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_read_lookahead_supported(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_security_enhanced_erase_unit_minutes")]
    #[doc(alias = "get_security_enhanced_erase_unit_minutes")]
    fn security_enhanced_erase_unit_minutes(&self) -> i32 {
        unsafe {
            ffi::udisks_drive_ata_get_security_enhanced_erase_unit_minutes(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_security_erase_unit_minutes")]
    #[doc(alias = "get_security_erase_unit_minutes")]
    fn security_erase_unit_minutes(&self) -> i32 {
        unsafe {
            ffi::udisks_drive_ata_get_security_erase_unit_minutes(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_security_frozen")]
    #[doc(alias = "get_security_frozen")]
    fn is_security_frozen(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_security_frozen(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_enabled")]
    #[doc(alias = "get_smart_enabled")]
    fn is_smart_enabled(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_smart_enabled(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_failing")]
    #[doc(alias = "get_smart_failing")]
    fn is_smart_failing(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_smart_failing(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_num_attributes_failed_in_the_past")]
    #[doc(alias = "get_smart_num_attributes_failed_in_the_past")]
    fn smart_num_attributes_failed_in_the_past(&self) -> i32 {
        unsafe {
            ffi::udisks_drive_ata_get_smart_num_attributes_failed_in_the_past(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_num_attributes_failing")]
    #[doc(alias = "get_smart_num_attributes_failing")]
    fn smart_num_attributes_failing(&self) -> i32 {
        unsafe {
            ffi::udisks_drive_ata_get_smart_num_attributes_failing(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_num_bad_sectors")]
    #[doc(alias = "get_smart_num_bad_sectors")]
    fn smart_num_bad_sectors(&self) -> i64 {
        unsafe {
            ffi::udisks_drive_ata_get_smart_num_bad_sectors(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_power_on_seconds")]
    #[doc(alias = "get_smart_power_on_seconds")]
    fn smart_power_on_seconds(&self) -> u64 {
        unsafe {
            ffi::udisks_drive_ata_get_smart_power_on_seconds(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_selftest_percent_remaining")]
    #[doc(alias = "get_smart_selftest_percent_remaining")]
    fn smart_selftest_percent_remaining(&self) -> i32 {
        unsafe {
            ffi::udisks_drive_ata_get_smart_selftest_percent_remaining(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_selftest_status")]
    #[doc(alias = "get_smart_selftest_status")]
    fn smart_selftest_status(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_drive_ata_get_smart_selftest_status(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_supported")]
    #[doc(alias = "get_smart_supported")]
    fn is_smart_supported(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_smart_supported(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_temperature")]
    #[doc(alias = "get_smart_temperature")]
    fn smart_temperature(&self) -> f64 {
        unsafe {
            ffi::udisks_drive_ata_get_smart_temperature(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_smart_updated")]
    #[doc(alias = "get_smart_updated")]
    fn smart_updated(&self) -> u64 {
        unsafe {
            ffi::udisks_drive_ata_get_smart_updated(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_drive_ata_get_write_cache_enabled")]
    #[doc(alias = "get_write_cache_enabled")]
    fn is_write_cache_enabled(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_write_cache_enabled(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_get_write_cache_supported")]
    #[doc(alias = "get_write_cache_supported")]
    fn is_write_cache_supported(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_drive_ata_get_write_cache_supported(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_drive_ata_set_aam_enabled")]
    fn set_aam_enabled(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_aam_enabled(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_aam_supported")]
    fn set_aam_supported(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_aam_supported(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_aam_vendor_recommended_value")]
    fn set_aam_vendor_recommended_value(&self, value: i32) {
        unsafe {
            ffi::udisks_drive_ata_set_aam_vendor_recommended_value(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_apm_enabled")]
    fn set_apm_enabled(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_apm_enabled(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_apm_supported")]
    fn set_apm_supported(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_apm_supported(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_pm_enabled")]
    fn set_pm_enabled(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_pm_enabled(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_pm_supported")]
    fn set_pm_supported(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_pm_supported(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    #[doc(alias = "udisks_drive_ata_set_read_lookahead_enabled")]
    fn set_read_lookahead_enabled(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_read_lookahead_enabled(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    #[doc(alias = "udisks_drive_ata_set_read_lookahead_supported")]
    fn set_read_lookahead_supported(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_read_lookahead_supported(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_security_enhanced_erase_unit_minutes")]
    fn set_security_enhanced_erase_unit_minutes(&self, value: i32) {
        unsafe {
            ffi::udisks_drive_ata_set_security_enhanced_erase_unit_minutes(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_security_erase_unit_minutes")]
    fn set_security_erase_unit_minutes(&self, value: i32) {
        unsafe {
            ffi::udisks_drive_ata_set_security_erase_unit_minutes(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_security_frozen")]
    fn set_security_frozen(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_security_frozen(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_enabled")]
    fn set_smart_enabled(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_enabled(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_failing")]
    fn set_smart_failing(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_failing(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_num_attributes_failed_in_the_past")]
    fn set_smart_num_attributes_failed_in_the_past(&self, value: i32) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_num_attributes_failed_in_the_past(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_num_attributes_failing")]
    fn set_smart_num_attributes_failing(&self, value: i32) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_num_attributes_failing(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_num_bad_sectors")]
    fn set_smart_num_bad_sectors(&self, value: i64) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_num_bad_sectors(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_power_on_seconds")]
    fn set_smart_power_on_seconds(&self, value: u64) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_power_on_seconds(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_selftest_percent_remaining")]
    fn set_smart_selftest_percent_remaining(&self, value: i32) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_selftest_percent_remaining(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_selftest_status")]
    fn set_smart_selftest_status(&self, value: &str) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_selftest_status(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_supported")]
    fn set_smart_supported(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_supported(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_temperature")]
    fn set_smart_temperature(&self, value: f64) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_temperature(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_smart_updated")]
    fn set_smart_updated(&self, value: u64) {
        unsafe {
            ffi::udisks_drive_ata_set_smart_updated(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_drive_ata_set_write_cache_enabled")]
    fn set_write_cache_enabled(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_write_cache_enabled(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_drive_ata_set_write_cache_supported")]
    fn set_write_cache_supported(&self, value: bool) {
        unsafe {
            ffi::udisks_drive_ata_set_write_cache_supported(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    //#[doc(alias = "handle-pm-get-state")]
    //fn connect_handle_pm_get_state<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-pm-standby")]
    //fn connect_handle_pm_standby<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-pm-wakeup")]
    //fn connect_handle_pm_wakeup<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-security-erase-unit")]
    //fn connect_handle_security_erase_unit<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-smart-get-attributes")]
    //fn connect_handle_smart_get_attributes<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-smart-selftest-abort")]
    //fn connect_handle_smart_selftest_abort<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-smart-selftest-start")]
    //fn connect_handle_smart_selftest_start<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-smart-set-enabled")]
    //fn connect_handle_smart_set_enabled<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-smart-update")]
    //fn connect_handle_smart_update<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    #[doc(alias = "aam-enabled")]
    fn connect_aam_enabled_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_aam_enabled_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::aam-enabled\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_aam_enabled_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "aam-supported")]
    fn connect_aam_supported_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_aam_supported_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::aam-supported\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_aam_supported_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "aam-vendor-recommended-value")]
    fn connect_aam_vendor_recommended_value_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_aam_vendor_recommended_value_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::aam-vendor-recommended-value\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_aam_vendor_recommended_value_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "apm-enabled")]
    fn connect_apm_enabled_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_apm_enabled_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::apm-enabled\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_apm_enabled_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "apm-supported")]
    fn connect_apm_supported_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_apm_supported_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::apm-supported\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_apm_supported_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "pm-enabled")]
    fn connect_pm_enabled_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pm_enabled_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::pm-enabled\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_pm_enabled_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "pm-supported")]
    fn connect_pm_supported_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_pm_supported_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::pm-supported\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_pm_supported_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    #[doc(alias = "read-lookahead-enabled")]
    fn connect_read_lookahead_enabled_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_read_lookahead_enabled_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::read-lookahead-enabled\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_read_lookahead_enabled_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    #[doc(alias = "read-lookahead-supported")]
    fn connect_read_lookahead_supported_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_read_lookahead_supported_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::read-lookahead-supported\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_read_lookahead_supported_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "security-enhanced-erase-unit-minutes")]
    fn connect_security_enhanced_erase_unit_minutes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_security_enhanced_erase_unit_minutes_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::security-enhanced-erase-unit-minutes\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_security_enhanced_erase_unit_minutes_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "security-erase-unit-minutes")]
    fn connect_security_erase_unit_minutes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_security_erase_unit_minutes_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::security-erase-unit-minutes\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_security_erase_unit_minutes_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "security-frozen")]
    fn connect_security_frozen_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_security_frozen_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::security-frozen\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_security_frozen_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-enabled")]
    fn connect_smart_enabled_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_enabled_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-enabled\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_enabled_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-failing")]
    fn connect_smart_failing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_failing_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-failing\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_failing_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-num-attributes-failed-in-the-past")]
    fn connect_smart_num_attributes_failed_in_the_past_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_num_attributes_failed_in_the_past_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-num-attributes-failed-in-the-past\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_num_attributes_failed_in_the_past_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-num-attributes-failing")]
    fn connect_smart_num_attributes_failing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_num_attributes_failing_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-num-attributes-failing\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_num_attributes_failing_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-num-bad-sectors")]
    fn connect_smart_num_bad_sectors_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_num_bad_sectors_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-num-bad-sectors\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_num_bad_sectors_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-power-on-seconds")]
    fn connect_smart_power_on_seconds_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_power_on_seconds_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-power-on-seconds\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_power_on_seconds_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-selftest-percent-remaining")]
    fn connect_smart_selftest_percent_remaining_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_selftest_percent_remaining_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-selftest-percent-remaining\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_selftest_percent_remaining_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-selftest-status")]
    fn connect_smart_selftest_status_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_selftest_status_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-selftest-status\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_selftest_status_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-supported")]
    fn connect_smart_supported_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_supported_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-supported\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_supported_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-temperature")]
    fn connect_smart_temperature_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_temperature_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-temperature\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_temperature_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "smart-updated")]
    fn connect_smart_updated_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_smart_updated_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::smart-updated\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_smart_updated_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "write-cache-enabled")]
    fn connect_write_cache_enabled_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_write_cache_enabled_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::write-cache-enabled\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_write_cache_enabled_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "write-cache-supported")]
    fn connect_write_cache_supported_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_write_cache_supported_trampoline<P: IsA<DriveAta>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksDriveAta, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(DriveAta::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::write-cache-supported\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_write_cache_supported_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<DriveAta>> DriveAtaExt for O {}
