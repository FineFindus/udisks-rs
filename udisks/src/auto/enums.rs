// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use glib::{prelude::*,translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "UDisksError")]
pub enum Error {
    #[doc(alias = "UDISKS_ERROR_FAILED")]
    Failed,
    #[doc(alias = "UDISKS_ERROR_CANCELLED")]
    Cancelled,
    #[doc(alias = "UDISKS_ERROR_ALREADY_CANCELLED")]
    AlreadyCancelled,
    #[doc(alias = "UDISKS_ERROR_NOT_AUTHORIZED")]
    NotAuthorized,
    #[doc(alias = "UDISKS_ERROR_NOT_AUTHORIZED_CAN_OBTAIN")]
    NotAuthorizedCanObtain,
    #[doc(alias = "UDISKS_ERROR_NOT_AUTHORIZED_DISMISSED")]
    NotAuthorizedDismissed,
    #[doc(alias = "UDISKS_ERROR_ALREADY_MOUNTED")]
    AlreadyMounted,
    #[doc(alias = "UDISKS_ERROR_NOT_MOUNTED")]
    NotMounted,
    #[doc(alias = "UDISKS_ERROR_OPTION_NOT_PERMITTED")]
    OptionNotPermitted,
    #[doc(alias = "UDISKS_ERROR_MOUNTED_BY_OTHER_USER")]
    MountedByOtherUser,
    #[doc(alias = "UDISKS_ERROR_ALREADY_UNMOUNTING")]
    AlreadyUnmounting,
    #[doc(alias = "UDISKS_ERROR_NOT_SUPPORTED")]
    NotSupported,
    #[doc(alias = "UDISKS_ERROR_TIMED_OUT")]
    TimedOut,
    #[doc(alias = "UDISKS_ERROR_WOULD_WAKEUP")]
    WouldWakeup,
    #[doc(alias = "UDISKS_ERROR_DEVICE_BUSY")]
    DeviceBusy,
    #[doc(alias = "UDISKS_ERROR_ISCSI_DAEMON_TRANSPORT_FAILED")]
    IscsiDaemonTransportFailed,
    #[doc(alias = "UDISKS_ERROR_ISCSI_HOST_NOT_FOUND")]
    IscsiHostNotFound,
    #[doc(alias = "UDISKS_ERROR_ISCSI_IDMB")]
    IscsiIdmb,
    #[doc(alias = "UDISKS_ERROR_ISCSI_LOGIN_FAILED")]
    IscsiLoginFailed,
    #[doc(alias = "UDISKS_ERROR_ISCSI_LOGIN_AUTH_FAILED")]
    IscsiLoginAuthFailed,
    #[doc(alias = "UDISKS_ERROR_ISCSI_LOGIN_FATAL")]
    IscsiLoginFatal,
    #[doc(alias = "UDISKS_ERROR_ISCSI_LOGOUT_FAILED")]
    IscsiLogoutFailed,
    #[doc(alias = "UDISKS_ERROR_ISCSI_NO_FIRMWARE")]
    IscsiNoFirmware,
    #[doc(alias = "UDISKS_ERROR_ISCSI_NO_OBJECTS_FOUND")]
    IscsiNoObjectsFound,
    #[doc(alias = "UDISKS_ERROR_ISCSI_NOT_CONNECTED")]
    IscsiNotConnected,
    #[doc(alias = "UDISKS_ERROR_ISCSI_TRANSPORT_FAILED")]
    IscsiTransportFailed,
    #[doc(alias = "UDISKS_ERROR_ISCSI_UNKNOWN_DISCOVERY_TYPE")]
    IscsiUnknownDiscoveryType,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Error {
    type GlibType = ffi::UDisksError;

    fn into_glib(self) -> ffi::UDisksError {
match self {
            Self::Failed => ffi::UDISKS_ERROR_FAILED,
            Self::Cancelled => ffi::UDISKS_ERROR_CANCELLED,
            Self::AlreadyCancelled => ffi::UDISKS_ERROR_ALREADY_CANCELLED,
            Self::NotAuthorized => ffi::UDISKS_ERROR_NOT_AUTHORIZED,
            Self::NotAuthorizedCanObtain => ffi::UDISKS_ERROR_NOT_AUTHORIZED_CAN_OBTAIN,
            Self::NotAuthorizedDismissed => ffi::UDISKS_ERROR_NOT_AUTHORIZED_DISMISSED,
            Self::AlreadyMounted => ffi::UDISKS_ERROR_ALREADY_MOUNTED,
            Self::NotMounted => ffi::UDISKS_ERROR_NOT_MOUNTED,
            Self::OptionNotPermitted => ffi::UDISKS_ERROR_OPTION_NOT_PERMITTED,
            Self::MountedByOtherUser => ffi::UDISKS_ERROR_MOUNTED_BY_OTHER_USER,
            Self::AlreadyUnmounting => ffi::UDISKS_ERROR_ALREADY_UNMOUNTING,
            Self::NotSupported => ffi::UDISKS_ERROR_NOT_SUPPORTED,
            Self::TimedOut => ffi::UDISKS_ERROR_TIMED_OUT,
            Self::WouldWakeup => ffi::UDISKS_ERROR_WOULD_WAKEUP,
            Self::DeviceBusy => ffi::UDISKS_ERROR_DEVICE_BUSY,
            Self::IscsiDaemonTransportFailed => ffi::UDISKS_ERROR_ISCSI_DAEMON_TRANSPORT_FAILED,
            Self::IscsiHostNotFound => ffi::UDISKS_ERROR_ISCSI_HOST_NOT_FOUND,
            Self::IscsiIdmb => ffi::UDISKS_ERROR_ISCSI_IDMB,
            Self::IscsiLoginFailed => ffi::UDISKS_ERROR_ISCSI_LOGIN_FAILED,
            Self::IscsiLoginAuthFailed => ffi::UDISKS_ERROR_ISCSI_LOGIN_AUTH_FAILED,
            Self::IscsiLoginFatal => ffi::UDISKS_ERROR_ISCSI_LOGIN_FATAL,
            Self::IscsiLogoutFailed => ffi::UDISKS_ERROR_ISCSI_LOGOUT_FAILED,
            Self::IscsiNoFirmware => ffi::UDISKS_ERROR_ISCSI_NO_FIRMWARE,
            Self::IscsiNoObjectsFound => ffi::UDISKS_ERROR_ISCSI_NO_OBJECTS_FOUND,
            Self::IscsiNotConnected => ffi::UDISKS_ERROR_ISCSI_NOT_CONNECTED,
            Self::IscsiTransportFailed => ffi::UDISKS_ERROR_ISCSI_TRANSPORT_FAILED,
            Self::IscsiUnknownDiscoveryType => ffi::UDISKS_ERROR_ISCSI_UNKNOWN_DISCOVERY_TYPE,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::UDisksError> for Error {
    unsafe fn from_glib(value: ffi::UDisksError) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::UDISKS_ERROR_FAILED => Self::Failed,
            ffi::UDISKS_ERROR_CANCELLED => Self::Cancelled,
            ffi::UDISKS_ERROR_ALREADY_CANCELLED => Self::AlreadyCancelled,
            ffi::UDISKS_ERROR_NOT_AUTHORIZED => Self::NotAuthorized,
            ffi::UDISKS_ERROR_NOT_AUTHORIZED_CAN_OBTAIN => Self::NotAuthorizedCanObtain,
            ffi::UDISKS_ERROR_NOT_AUTHORIZED_DISMISSED => Self::NotAuthorizedDismissed,
            ffi::UDISKS_ERROR_ALREADY_MOUNTED => Self::AlreadyMounted,
            ffi::UDISKS_ERROR_NOT_MOUNTED => Self::NotMounted,
            ffi::UDISKS_ERROR_OPTION_NOT_PERMITTED => Self::OptionNotPermitted,
            ffi::UDISKS_ERROR_MOUNTED_BY_OTHER_USER => Self::MountedByOtherUser,
            ffi::UDISKS_ERROR_ALREADY_UNMOUNTING => Self::AlreadyUnmounting,
            ffi::UDISKS_ERROR_NOT_SUPPORTED => Self::NotSupported,
            ffi::UDISKS_ERROR_TIMED_OUT => Self::TimedOut,
            ffi::UDISKS_ERROR_WOULD_WAKEUP => Self::WouldWakeup,
            ffi::UDISKS_ERROR_DEVICE_BUSY => Self::DeviceBusy,
            ffi::UDISKS_ERROR_ISCSI_DAEMON_TRANSPORT_FAILED => Self::IscsiDaemonTransportFailed,
            ffi::UDISKS_ERROR_ISCSI_HOST_NOT_FOUND => Self::IscsiHostNotFound,
            ffi::UDISKS_ERROR_ISCSI_IDMB => Self::IscsiIdmb,
            ffi::UDISKS_ERROR_ISCSI_LOGIN_FAILED => Self::IscsiLoginFailed,
            ffi::UDISKS_ERROR_ISCSI_LOGIN_AUTH_FAILED => Self::IscsiLoginAuthFailed,
            ffi::UDISKS_ERROR_ISCSI_LOGIN_FATAL => Self::IscsiLoginFatal,
            ffi::UDISKS_ERROR_ISCSI_LOGOUT_FAILED => Self::IscsiLogoutFailed,
            ffi::UDISKS_ERROR_ISCSI_NO_FIRMWARE => Self::IscsiNoFirmware,
            ffi::UDISKS_ERROR_ISCSI_NO_OBJECTS_FOUND => Self::IscsiNoObjectsFound,
            ffi::UDISKS_ERROR_ISCSI_NOT_CONNECTED => Self::IscsiNotConnected,
            ffi::UDISKS_ERROR_ISCSI_TRANSPORT_FAILED => Self::IscsiTransportFailed,
            ffi::UDISKS_ERROR_ISCSI_UNKNOWN_DISCOVERY_TYPE => Self::IscsiUnknownDiscoveryType,
            value => Self::__Unknown(value),
}
}
}

impl glib::error::ErrorDomain for Error {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();
        
        unsafe { from_glib(ffi::udisks_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
}
    }
}

impl StaticType for Error {
                #[inline]
    #[doc(alias = "udisks_error_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::udisks_error_get_type()) }
                }
            }

impl glib::HasParamSpec for Error {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for Error {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Error {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Error {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Error> for glib::Value {
    #[inline]
    fn from(v: Error) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

