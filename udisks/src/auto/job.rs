// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "UDisksJob")]
    pub struct Job(Interface<ffi::UDisksJob, ffi::UDisksJobIface>);

    match fn {
        type_ => || ffi::udisks_job_get_type(),
    }
}

impl Job {
        pub const NONE: Option<&'static Job> = None;
    

    //#[doc(alias = "udisks_job_interface_info")]
    //pub fn interface_info() -> /*Ignored*/Option<gio::DBusInterfaceInfo> {
    //    unsafe { TODO: call ffi:udisks_job_interface_info() }
    //}

    //#[doc(alias = "udisks_job_override_properties")]
    //pub fn override_properties(klass: /*Ignored*/&mut glib::ObjectClass, property_id_begin: u32) -> u32 {
    //    unsafe { TODO: call ffi:udisks_job_override_properties() }
    //}
}

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::Job>> Sealed for T {}
}

pub trait JobExt: IsA<Job> + sealed::Sealed + 'static {
    //#[doc(alias = "udisks_job_call_cancel")]
    //fn call_cancel<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_job_call_cancel() }
    //}

    //
    //fn call_cancel_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_cancel(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_job_call_cancel_sync")]
    //fn call_cancel_sync(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_job_call_cancel_sync() }
    //}

    //#[doc(alias = "udisks_job_complete_cancel")]
    //fn complete_cancel(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_job_complete_cancel() }
    //}

    #[doc(alias = "udisks_job_dup_objects")]
    fn dup_objects(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_job_dup_objects(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_job_dup_operation")]
    fn dup_operation(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_job_dup_operation(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_job_emit_completed")]
    fn emit_completed(&self, arg_success: bool, arg_message: &str) {
        unsafe {
            ffi::udisks_job_emit_completed(self.as_ref().to_glib_none().0, arg_success.into_glib(), arg_message.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_job_get_bytes")]
    #[doc(alias = "get_bytes")]
    fn bytes(&self) -> u64 {
        unsafe {
            ffi::udisks_job_get_bytes(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_job_get_cancelable")]
    #[doc(alias = "get_cancelable")]
    fn is_cancelable(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_job_get_cancelable(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_job_get_expected_end_time")]
    #[doc(alias = "get_expected_end_time")]
    fn expected_end_time(&self) -> u64 {
        unsafe {
            ffi::udisks_job_get_expected_end_time(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_job_get_objects")]
    #[doc(alias = "get_objects")]
    fn objects(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::udisks_job_get_objects(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_job_get_operation")]
    #[doc(alias = "get_operation")]
    fn operation(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_job_get_operation(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_job_get_progress")]
    #[doc(alias = "get_progress")]
    fn progress(&self) -> f64 {
        unsafe {
            ffi::udisks_job_get_progress(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_job_get_progress_valid")]
    #[doc(alias = "get_progress_valid")]
    fn is_progress_valid(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_job_get_progress_valid(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_job_get_rate")]
    #[doc(alias = "get_rate")]
    fn rate(&self) -> u64 {
        unsafe {
            ffi::udisks_job_get_rate(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_job_get_start_time")]
    #[doc(alias = "get_start_time")]
    fn start_time(&self) -> u64 {
        unsafe {
            ffi::udisks_job_get_start_time(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_job_get_started_by_uid")]
    #[doc(alias = "get_started_by_uid")]
    fn started_by_uid(&self) -> u32 {
        unsafe {
            ffi::udisks_job_get_started_by_uid(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_job_set_bytes")]
    fn set_bytes(&self, value: u64) {
        unsafe {
            ffi::udisks_job_set_bytes(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_job_set_cancelable")]
    fn set_cancelable(&self, value: bool) {
        unsafe {
            ffi::udisks_job_set_cancelable(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_job_set_expected_end_time")]
    fn set_expected_end_time(&self, value: u64) {
        unsafe {
            ffi::udisks_job_set_expected_end_time(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_job_set_operation")]
    fn set_operation(&self, value: &str) {
        unsafe {
            ffi::udisks_job_set_operation(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_job_set_progress")]
    fn set_progress(&self, value: f64) {
        unsafe {
            ffi::udisks_job_set_progress(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_job_set_progress_valid")]
    fn set_progress_valid(&self, value: bool) {
        unsafe {
            ffi::udisks_job_set_progress_valid(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_job_set_rate")]
    fn set_rate(&self, value: u64) {
        unsafe {
            ffi::udisks_job_set_rate(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_job_set_start_time")]
    fn set_start_time(&self, value: u64) {
        unsafe {
            ffi::udisks_job_set_start_time(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_job_set_started_by_uid")]
    fn set_started_by_uid(&self, value: u32) {
        unsafe {
            ffi::udisks_job_set_started_by_uid(self.as_ref().to_glib_none().0, value);
        }
    }

    fn set_objects(&self, objects: &[&str]) {
        ObjectExt::set_property(self.as_ref(),"objects", objects)
    }

    #[doc(alias = "completed")]
    fn connect_completed<F: Fn(&Self, bool, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn completed_trampoline<P: IsA<Job>, F: Fn(&P, bool, &str) + 'static>(this: *mut ffi::UDisksJob, arg_success: glib::ffi::gboolean, arg_message: *mut libc::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref(), from_glib(arg_success), &glib::GString::from_glib_borrow(arg_message))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"completed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(completed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[doc(alias = "handle-cancel")]
    //fn connect_handle_cancel<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    #[doc(alias = "bytes")]
    fn connect_bytes_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_bytes_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::bytes\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_bytes_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "cancelable")]
    fn connect_cancelable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_cancelable_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::cancelable\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_cancelable_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "expected-end-time")]
    fn connect_expected_end_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_expected_end_time_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::expected-end-time\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_expected_end_time_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "objects")]
    fn connect_objects_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_objects_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::objects\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_objects_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "operation")]
    fn connect_operation_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_operation_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::operation\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_operation_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "progress")]
    fn connect_progress_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_progress_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::progress\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_progress_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "progress-valid")]
    fn connect_progress_valid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_progress_valid_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::progress-valid\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_progress_valid_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "rate")]
    fn connect_rate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_rate_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::rate\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_rate_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "start-time")]
    fn connect_start_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_start_time_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::start-time\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_start_time_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "started-by-uid")]
    fn connect_started_by_uid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_started_by_uid_trampoline<P: IsA<Job>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksJob, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Job::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::started-by-uid\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_started_by_uid_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Job>> JobExt for O {}
