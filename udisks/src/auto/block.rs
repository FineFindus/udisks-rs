// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "UDisksBlock")]
    pub struct Block(Interface<ffi::UDisksBlock, ffi::UDisksBlockIface>);

    match fn {
        type_ => || ffi::udisks_block_get_type(),
    }
}

impl Block {
        pub const NONE: Option<&'static Block> = None;
    

    //#[doc(alias = "udisks_block_interface_info")]
    //pub fn interface_info() -> /*Ignored*/Option<gio::DBusInterfaceInfo> {
    //    unsafe { TODO: call ffi:udisks_block_interface_info() }
    //}

    //#[doc(alias = "udisks_block_override_properties")]
    //pub fn override_properties(klass: /*Ignored*/&mut glib::ObjectClass, property_id_begin: u32) -> u32 {
    //    unsafe { TODO: call ffi:udisks_block_override_properties() }
    //}
}

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::Block>> Sealed for T {}
}

pub trait BlockExt: IsA<Block> + sealed::Sealed + 'static {
    //#[doc(alias = "udisks_block_call_add_configuration_item")]
    //fn call_add_configuration_item<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_add_configuration_item() }
    //}

    //
    //fn call_add_configuration_item_future(&self, arg_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_item = arg_item.clone();
        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_add_configuration_item(
        //        &arg_item,
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_add_configuration_item_sync")]
    //fn call_add_configuration_item_sync(&self, arg_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_add_configuration_item_sync() }
    //}

    //#[doc(alias = "udisks_block_call_format")]
    //fn call_format<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_type: &str, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_format() }
    //}

    //
    //fn call_format_future(&self, arg_type: &str, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_type = String::from(arg_type);
        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_format(
        //        &arg_type,
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_format_sync")]
    //fn call_format_sync(&self, arg_type: &str, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_format_sync() }
    //}

    //#[doc(alias = "udisks_block_call_get_secret_configuration")]
    //fn call_get_secret_configuration<P: FnOnce(Result</*Ignored*/glib::Variant, /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_get_secret_configuration() }
    //}

    //
    //fn call_get_secret_configuration_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result</*Ignored*/glib::Variant, /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_get_secret_configuration(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_get_secret_configuration_sync")]
    //fn call_get_secret_configuration_sync(&self, arg_options: /*Ignored*/&glib::Variant, out_configuration: /*Ignored*/glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_get_secret_configuration_sync() }
    //}

    //#[cfg(feature = "v2_7_3")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    //#[doc(alias = "udisks_block_call_open_device")]
    //fn call_open_device<P: FnOnce(Result<(/*Ignored*/glib::Variant, /*Ignored*/gio::UnixFDList), /*Ignored*/glib::Error>) + 'static>(&self, arg_mode: &str, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_open_device() }
    //}

    //
    //#[cfg(feature = "v2_7_3")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    //fn call_open_device_future(&self, arg_mode: &str, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>) -> Pin<Box_<dyn std::future::Future<Output = Result<(/*Ignored*/glib::Variant, /*Ignored*/gio::UnixFDList), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_mode = String::from(arg_mode);
        //let arg_options = arg_options.clone();
        //let fd_list = fd_list.map(ToOwned::to_owned);
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_open_device(
        //        &arg_mode,
        //        &arg_options,
        //        fd_list.as_ref().map(::std::borrow::Borrow::borrow),
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[cfg(feature = "v2_7_3")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    //#[doc(alias = "udisks_block_call_open_device_sync")]
    //fn call_open_device_sync(&self, arg_mode: &str, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>, out_fd: /*Ignored*/glib::Variant, out_fd_list: /*Ignored*/gio::UnixFDList, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_open_device_sync() }
    //}

    //#[doc(alias = "udisks_block_call_open_for_backup")]
    //fn call_open_for_backup<P: FnOnce(Result<(/*Ignored*/glib::Variant, /*Ignored*/gio::UnixFDList), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_open_for_backup() }
    //}

    //
    //fn call_open_for_backup_future(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>) -> Pin<Box_<dyn std::future::Future<Output = Result<(/*Ignored*/glib::Variant, /*Ignored*/gio::UnixFDList), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //let fd_list = fd_list.map(ToOwned::to_owned);
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_open_for_backup(
        //        &arg_options,
        //        fd_list.as_ref().map(::std::borrow::Borrow::borrow),
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_open_for_backup_sync")]
    //fn call_open_for_backup_sync(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>, out_fd: /*Ignored*/glib::Variant, out_fd_list: /*Ignored*/gio::UnixFDList, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_open_for_backup_sync() }
    //}

    //#[doc(alias = "udisks_block_call_open_for_benchmark")]
    //fn call_open_for_benchmark<P: FnOnce(Result<(/*Ignored*/glib::Variant, /*Ignored*/gio::UnixFDList), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_open_for_benchmark() }
    //}

    //
    //fn call_open_for_benchmark_future(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>) -> Pin<Box_<dyn std::future::Future<Output = Result<(/*Ignored*/glib::Variant, /*Ignored*/gio::UnixFDList), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //let fd_list = fd_list.map(ToOwned::to_owned);
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_open_for_benchmark(
        //        &arg_options,
        //        fd_list.as_ref().map(::std::borrow::Borrow::borrow),
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_open_for_benchmark_sync")]
    //fn call_open_for_benchmark_sync(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>, out_fd: /*Ignored*/glib::Variant, out_fd_list: /*Ignored*/gio::UnixFDList, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_open_for_benchmark_sync() }
    //}

    //#[doc(alias = "udisks_block_call_open_for_restore")]
    //fn call_open_for_restore<P: FnOnce(Result<(/*Ignored*/glib::Variant, /*Ignored*/gio::UnixFDList), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_open_for_restore() }
    //}

    //
    //fn call_open_for_restore_future(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>) -> Pin<Box_<dyn std::future::Future<Output = Result<(/*Ignored*/glib::Variant, /*Ignored*/gio::UnixFDList), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //let fd_list = fd_list.map(ToOwned::to_owned);
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_open_for_restore(
        //        &arg_options,
        //        fd_list.as_ref().map(::std::borrow::Borrow::borrow),
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_open_for_restore_sync")]
    //fn call_open_for_restore_sync(&self, arg_options: /*Ignored*/&glib::Variant, fd_list: /*Ignored*/Option<&gio::UnixFDList>, out_fd: /*Ignored*/glib::Variant, out_fd_list: /*Ignored*/gio::UnixFDList, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_open_for_restore_sync() }
    //}

    //#[doc(alias = "udisks_block_call_remove_configuration_item")]
    //fn call_remove_configuration_item<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_remove_configuration_item() }
    //}

    //
    //fn call_remove_configuration_item_future(&self, arg_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_item = arg_item.clone();
        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_remove_configuration_item(
        //        &arg_item,
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_remove_configuration_item_sync")]
    //fn call_remove_configuration_item_sync(&self, arg_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_remove_configuration_item_sync() }
    //}

    //#[doc(alias = "udisks_block_call_rescan")]
    //fn call_rescan<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_rescan() }
    //}

    //
    //fn call_rescan_future(&self, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_rescan(
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_rescan_sync")]
    //fn call_rescan_sync(&self, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_rescan_sync() }
    //}

    //#[doc(alias = "udisks_block_call_update_configuration_item")]
    //fn call_update_configuration_item<P: FnOnce(Result<(), /*Ignored*/glib::Error>) + 'static>(&self, arg_old_item: /*Ignored*/&glib::Variant, arg_new_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:udisks_block_call_update_configuration_item() }
    //}

    //
    //fn call_update_configuration_item_future(&self, arg_old_item: /*Ignored*/&glib::Variant, arg_new_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant) -> Pin<Box_<dyn std::future::Future<Output = Result<(), /*Ignored*/glib::Error>> + 'static>> {

        //let arg_old_item = arg_old_item.clone();
        //let arg_new_item = arg_new_item.clone();
        //let arg_options = arg_options.clone();
        //Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
        //    obj.call_update_configuration_item(
        //        &arg_old_item,
        //        &arg_new_item,
        //        &arg_options,
        //        Some(cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );
        //}))
    //}

    //#[doc(alias = "udisks_block_call_update_configuration_item_sync")]
    //fn call_update_configuration_item_sync(&self, arg_old_item: /*Ignored*/&glib::Variant, arg_new_item: /*Ignored*/&glib::Variant, arg_options: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> bool {
    //    unsafe { TODO: call ffi:udisks_block_call_update_configuration_item_sync() }
    //}

    //#[doc(alias = "udisks_block_complete_add_configuration_item")]
    //fn complete_add_configuration_item(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_block_complete_add_configuration_item() }
    //}

    //#[doc(alias = "udisks_block_complete_format")]
    //fn complete_format(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_block_complete_format() }
    //}

    //#[doc(alias = "udisks_block_complete_get_secret_configuration")]
    //fn complete_get_secret_configuration(&self, invocation: /*Ignored*/gio::DBusMethodInvocation, configuration: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:udisks_block_complete_get_secret_configuration() }
    //}

    //#[cfg(feature = "v2_7_3")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    //#[doc(alias = "udisks_block_complete_open_device")]
    //fn complete_open_device(&self, invocation: /*Ignored*/gio::DBusMethodInvocation, fd_list: /*Ignored*/Option<&gio::UnixFDList>, fd: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:udisks_block_complete_open_device() }
    //}

    //#[doc(alias = "udisks_block_complete_open_for_backup")]
    //fn complete_open_for_backup(&self, invocation: /*Ignored*/gio::DBusMethodInvocation, fd_list: /*Ignored*/Option<&gio::UnixFDList>, fd: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:udisks_block_complete_open_for_backup() }
    //}

    //#[doc(alias = "udisks_block_complete_open_for_benchmark")]
    //fn complete_open_for_benchmark(&self, invocation: /*Ignored*/gio::DBusMethodInvocation, fd_list: /*Ignored*/Option<&gio::UnixFDList>, fd: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:udisks_block_complete_open_for_benchmark() }
    //}

    //#[doc(alias = "udisks_block_complete_open_for_restore")]
    //fn complete_open_for_restore(&self, invocation: /*Ignored*/gio::DBusMethodInvocation, fd_list: /*Ignored*/Option<&gio::UnixFDList>, fd: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:udisks_block_complete_open_for_restore() }
    //}

    //#[doc(alias = "udisks_block_complete_remove_configuration_item")]
    //fn complete_remove_configuration_item(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_block_complete_remove_configuration_item() }
    //}

    //#[doc(alias = "udisks_block_complete_rescan")]
    //fn complete_rescan(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_block_complete_rescan() }
    //}

    //#[doc(alias = "udisks_block_complete_update_configuration_item")]
    //fn complete_update_configuration_item(&self, invocation: /*Ignored*/gio::DBusMethodInvocation) {
    //    unsafe { TODO: call ffi:udisks_block_complete_update_configuration_item() }
    //}

    //#[doc(alias = "udisks_block_dup_configuration")]
    //fn dup_configuration(&self) -> /*Ignored*/Option<glib::Variant> {
    //    unsafe { TODO: call ffi:udisks_block_dup_configuration() }
    //}

    #[doc(alias = "udisks_block_dup_crypto_backing_device")]
    fn dup_crypto_backing_device(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_crypto_backing_device(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_device")]
    fn dup_device(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_device(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_drive")]
    fn dup_drive(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_drive(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_hint_icon_name")]
    fn dup_hint_icon_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_hint_icon_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_hint_name")]
    fn dup_hint_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_hint_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_hint_symbolic_icon_name")]
    fn dup_hint_symbolic_icon_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_hint_symbolic_icon_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_id")]
    fn dup_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_id(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_id_label")]
    fn dup_id_label(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_id_label(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_id_type")]
    fn dup_id_type(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_id_type(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_id_usage")]
    fn dup_id_usage(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_id_usage(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_id_uuid")]
    fn dup_id_uuid(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_id_uuid(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_id_version")]
    fn dup_id_version(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_id_version(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_mdraid")]
    fn dup_mdraid(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_mdraid(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_mdraid_member")]
    fn dup_mdraid_member(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_mdraid_member(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_preferred_device")]
    fn dup_preferred_device(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::udisks_block_dup_preferred_device(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_symlinks")]
    fn dup_symlinks(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_block_dup_symlinks(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_dup_userspace_mount_options")]
    fn dup_userspace_mount_options(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::udisks_block_dup_userspace_mount_options(self.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "udisks_block_get_configuration")]
    //#[doc(alias = "get_configuration")]
    //fn configuration(&self) -> /*Ignored*/Option<glib::Variant> {
    //    unsafe { TODO: call ffi:udisks_block_get_configuration() }
    //}

    #[doc(alias = "udisks_block_get_crypto_backing_device")]
    #[doc(alias = "get_crypto_backing_device")]
    fn crypto_backing_device(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_crypto_backing_device(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_device")]
    #[doc(alias = "get_device")]
    fn device(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_device(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_device_number")]
    #[doc(alias = "get_device_number")]
    fn device_number(&self) -> u64 {
        unsafe {
            ffi::udisks_block_get_device_number(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_block_get_drive")]
    #[doc(alias = "get_drive")]
    fn drive(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_drive(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_hint_auto")]
    #[doc(alias = "get_hint_auto")]
    fn is_hint_auto(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_block_get_hint_auto(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_hint_icon_name")]
    #[doc(alias = "get_hint_icon_name")]
    fn hint_icon_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_hint_icon_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_hint_ignore")]
    #[doc(alias = "get_hint_ignore")]
    fn is_hint_ignore(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_block_get_hint_ignore(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_hint_name")]
    #[doc(alias = "get_hint_name")]
    fn hint_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_hint_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_hint_partitionable")]
    #[doc(alias = "get_hint_partitionable")]
    fn is_hint_partitionable(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_block_get_hint_partitionable(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_hint_symbolic_icon_name")]
    #[doc(alias = "get_hint_symbolic_icon_name")]
    fn hint_symbolic_icon_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_hint_symbolic_icon_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_hint_system")]
    #[doc(alias = "get_hint_system")]
    fn is_hint_system(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_block_get_hint_system(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_id")]
    #[doc(alias = "get_id")]
    fn id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_id(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_id_label")]
    #[doc(alias = "get_id_label")]
    fn id_label(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_id_label(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_id_type")]
    #[doc(alias = "get_id_type")]
    fn id_type(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_id_type(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_id_usage")]
    #[doc(alias = "get_id_usage")]
    fn id_usage(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_id_usage(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_id_uuid")]
    #[doc(alias = "get_id_uuid")]
    fn id_uuid(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_id_uuid(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_id_version")]
    #[doc(alias = "get_id_version")]
    fn id_version(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_id_version(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_mdraid")]
    #[doc(alias = "get_mdraid")]
    fn mdraid(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_mdraid(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_mdraid_member")]
    #[doc(alias = "get_mdraid_member")]
    fn mdraid_member(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_mdraid_member(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_preferred_device")]
    #[doc(alias = "get_preferred_device")]
    fn preferred_device(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::udisks_block_get_preferred_device(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_read_only")]
    #[doc(alias = "get_read_only")]
    fn is_read_only(&self) -> bool {
        unsafe {
            from_glib(ffi::udisks_block_get_read_only(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_size")]
    #[doc(alias = "get_size")]
    fn size(&self) -> u64 {
        unsafe {
            ffi::udisks_block_get_size(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "udisks_block_get_symlinks")]
    #[doc(alias = "get_symlinks")]
    fn symlinks(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::udisks_block_get_symlinks(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "udisks_block_get_userspace_mount_options")]
    #[doc(alias = "get_userspace_mount_options")]
    fn userspace_mount_options(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::udisks_block_get_userspace_mount_options(self.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "udisks_block_set_configuration")]
    //fn set_configuration(&self, value: /*Ignored*/&glib::Variant) {
    //    unsafe { TODO: call ffi:udisks_block_set_configuration() }
    //}

    #[doc(alias = "udisks_block_set_crypto_backing_device")]
    fn set_crypto_backing_device(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_crypto_backing_device(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_device")]
    fn set_device(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_device(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_device_number")]
    fn set_device_number(&self, value: u64) {
        unsafe {
            ffi::udisks_block_set_device_number(self.as_ref().to_glib_none().0, value);
        }
    }

    #[doc(alias = "udisks_block_set_drive")]
    fn set_drive(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_drive(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_hint_auto")]
    fn set_hint_auto(&self, value: bool) {
        unsafe {
            ffi::udisks_block_set_hint_auto(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_block_set_hint_icon_name")]
    fn set_hint_icon_name(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_hint_icon_name(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_hint_ignore")]
    fn set_hint_ignore(&self, value: bool) {
        unsafe {
            ffi::udisks_block_set_hint_ignore(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_block_set_hint_name")]
    fn set_hint_name(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_hint_name(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_hint_partitionable")]
    fn set_hint_partitionable(&self, value: bool) {
        unsafe {
            ffi::udisks_block_set_hint_partitionable(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_block_set_hint_symbolic_icon_name")]
    fn set_hint_symbolic_icon_name(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_hint_symbolic_icon_name(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_hint_system")]
    fn set_hint_system(&self, value: bool) {
        unsafe {
            ffi::udisks_block_set_hint_system(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_block_set_id")]
    fn set_id(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_id(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_id_label")]
    fn set_id_label(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_id_label(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_id_type")]
    fn set_id_type(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_id_type(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_id_usage")]
    fn set_id_usage(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_id_usage(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_id_uuid")]
    fn set_id_uuid(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_id_uuid(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_id_version")]
    fn set_id_version(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_id_version(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_mdraid")]
    fn set_mdraid(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_mdraid(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_mdraid_member")]
    fn set_mdraid_member(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_mdraid_member(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_preferred_device")]
    fn set_preferred_device(&self, value: &str) {
        unsafe {
            ffi::udisks_block_set_preferred_device(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "udisks_block_set_read_only")]
    fn set_read_only(&self, value: bool) {
        unsafe {
            ffi::udisks_block_set_read_only(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    #[doc(alias = "udisks_block_set_size")]
    fn set_size(&self, value: u64) {
        unsafe {
            ffi::udisks_block_set_size(self.as_ref().to_glib_none().0, value);
        }
    }

    fn set_symlinks(&self, symlinks: &[&str]) {
        ObjectExt::set_property(self.as_ref(),"symlinks", symlinks)
    }

    #[doc(alias = "userspace-mount-options")]
    fn set_userspace_mount_options(&self, userspace_mount_options: &[&str]) {
        ObjectExt::set_property(self.as_ref(),"userspace-mount-options", userspace_mount_options)
    }

    //#[doc(alias = "handle-add-configuration-item")]
    //fn connect_handle_add_configuration_item<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_item: GLib.Variant
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-format")]
    //fn connect_handle_format<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-get-secret-configuration")]
    //fn connect_handle_get_secret_configuration<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[cfg(feature = "v2_7_3")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    //#[doc(alias = "handle-open-device")]
    //fn connect_handle_open_device<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored fd_list: Gio.UnixFDList
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-open-for-backup")]
    //fn connect_handle_open_for_backup<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored fd_list: Gio.UnixFDList
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-open-for-benchmark")]
    //fn connect_handle_open_for_benchmark<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored fd_list: Gio.UnixFDList
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-open-for-restore")]
    //fn connect_handle_open_for_restore<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored fd_list: Gio.UnixFDList
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-remove-configuration-item")]
    //fn connect_handle_remove_configuration_item<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_item: GLib.Variant
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-rescan")]
    //fn connect_handle_rescan<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_options: GLib.Variant
    //}

    //#[doc(alias = "handle-update-configuration-item")]
    //fn connect_handle_update_configuration_item<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored invocation: Gio.DBusMethodInvocation
    //    Ignored arg_old_item: GLib.Variant
    //    Ignored arg_new_item: GLib.Variant
    //    Ignored arg_options: GLib.Variant
    //}

    #[doc(alias = "configuration")]
    fn connect_configuration_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_configuration_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::configuration\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_configuration_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "crypto-backing-device")]
    fn connect_crypto_backing_device_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_crypto_backing_device_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::crypto-backing-device\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_crypto_backing_device_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "device")]
    fn connect_device_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_device_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::device\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_device_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "device-number")]
    fn connect_device_number_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_device_number_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::device-number\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_device_number_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "drive")]
    fn connect_drive_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_drive_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::drive\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_drive_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "hint-auto")]
    fn connect_hint_auto_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hint_auto_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::hint-auto\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_hint_auto_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "hint-icon-name")]
    fn connect_hint_icon_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hint_icon_name_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::hint-icon-name\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_hint_icon_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "hint-ignore")]
    fn connect_hint_ignore_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hint_ignore_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::hint-ignore\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_hint_ignore_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "hint-name")]
    fn connect_hint_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hint_name_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::hint-name\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_hint_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "hint-partitionable")]
    fn connect_hint_partitionable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hint_partitionable_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::hint-partitionable\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_hint_partitionable_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "hint-symbolic-icon-name")]
    fn connect_hint_symbolic_icon_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hint_symbolic_icon_name_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::hint-symbolic-icon-name\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_hint_symbolic_icon_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "hint-system")]
    fn connect_hint_system_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hint_system_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::hint-system\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_hint_system_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "id")]
    fn connect_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::id\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "id-label")]
    fn connect_id_label_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_label_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::id-label\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_id_label_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "id-type")]
    fn connect_id_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_type_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::id-type\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_id_type_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "id-usage")]
    fn connect_id_usage_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_usage_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::id-usage\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_id_usage_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "id-uuid")]
    fn connect_id_uuid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_uuid_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::id-uuid\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_id_uuid_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "id-version")]
    fn connect_id_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_version_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::id-version\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_id_version_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mdraid")]
    fn connect_mdraid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mdraid_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::mdraid\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_mdraid_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "mdraid-member")]
    fn connect_mdraid_member_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mdraid_member_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::mdraid-member\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_mdraid_member_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "preferred-device")]
    fn connect_preferred_device_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_preferred_device_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::preferred-device\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_preferred_device_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "read-only")]
    fn connect_read_only_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_read_only_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::read-only\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_read_only_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "size")]
    fn connect_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_size_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::size\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_size_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "symlinks")]
    fn connect_symlinks_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_symlinks_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::symlinks\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_symlinks_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "userspace-mount-options")]
    fn connect_userspace_mount_options_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_userspace_mount_options_trampoline<P: IsA<Block>, F: Fn(&P) + 'static>(this: *mut ffi::UDisksBlock, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Block::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::userspace-mount-options\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_userspace_mount_options_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Block>> BlockExt for O {}
