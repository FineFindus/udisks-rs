// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../..
// from ../../gir-files
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(docsrs, feature(doc_cfg))]


#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type UDisksError = c_int;
pub const UDISKS_ERROR_FAILED: UDisksError = 0;
pub const UDISKS_ERROR_CANCELLED: UDisksError = 1;
pub const UDISKS_ERROR_ALREADY_CANCELLED: UDisksError = 2;
pub const UDISKS_ERROR_NOT_AUTHORIZED: UDisksError = 3;
pub const UDISKS_ERROR_NOT_AUTHORIZED_CAN_OBTAIN: UDisksError = 4;
pub const UDISKS_ERROR_NOT_AUTHORIZED_DISMISSED: UDisksError = 5;
pub const UDISKS_ERROR_ALREADY_MOUNTED: UDisksError = 6;
pub const UDISKS_ERROR_NOT_MOUNTED: UDisksError = 7;
pub const UDISKS_ERROR_OPTION_NOT_PERMITTED: UDisksError = 8;
pub const UDISKS_ERROR_MOUNTED_BY_OTHER_USER: UDisksError = 9;
pub const UDISKS_ERROR_ALREADY_UNMOUNTING: UDisksError = 10;
pub const UDISKS_ERROR_NOT_SUPPORTED: UDisksError = 11;
pub const UDISKS_ERROR_TIMED_OUT: UDisksError = 12;
pub const UDISKS_ERROR_WOULD_WAKEUP: UDisksError = 13;
pub const UDISKS_ERROR_DEVICE_BUSY: UDisksError = 14;
pub const UDISKS_ERROR_ISCSI_DAEMON_TRANSPORT_FAILED: UDisksError = 15;
pub const UDISKS_ERROR_ISCSI_HOST_NOT_FOUND: UDisksError = 16;
pub const UDISKS_ERROR_ISCSI_IDMB: UDisksError = 17;
pub const UDISKS_ERROR_ISCSI_LOGIN_FAILED: UDisksError = 18;
pub const UDISKS_ERROR_ISCSI_LOGIN_AUTH_FAILED: UDisksError = 19;
pub const UDISKS_ERROR_ISCSI_LOGIN_FATAL: UDisksError = 20;
pub const UDISKS_ERROR_ISCSI_LOGOUT_FAILED: UDisksError = 21;
pub const UDISKS_ERROR_ISCSI_NO_FIRMWARE: UDisksError = 22;
pub const UDISKS_ERROR_ISCSI_NO_OBJECTS_FOUND: UDisksError = 23;
pub const UDISKS_ERROR_ISCSI_NOT_CONNECTED: UDisksError = 24;
pub const UDISKS_ERROR_ISCSI_TRANSPORT_FAILED: UDisksError = 25;
pub const UDISKS_ERROR_ISCSI_UNKNOWN_DISCOVERY_TYPE: UDisksError = 26;

// Constants
pub const UDISKS_ERROR_NUM_ENTRIES: c_int = 27;
pub const UDISKS_MAJOR_VERSION: c_int = 2;
pub const UDISKS_MICRO_VERSION: c_int = 4;
pub const UDISKS_MINOR_VERSION: c_int = 9;

// Flags
pub type UDisksPartitionTypeInfoFlags = c_uint;
pub const UDISKS_PARTITION_TYPE_INFO_FLAGS_NONE: UDisksPartitionTypeInfoFlags = 0;
pub const UDISKS_PARTITION_TYPE_INFO_FLAGS_SWAP: UDisksPartitionTypeInfoFlags = 1;
pub const UDISKS_PARTITION_TYPE_INFO_FLAGS_RAID: UDisksPartitionTypeInfoFlags = 2;
pub const UDISKS_PARTITION_TYPE_INFO_FLAGS_HIDDEN: UDisksPartitionTypeInfoFlags = 4;
pub const UDISKS_PARTITION_TYPE_INFO_FLAGS_CREATE_ONLY: UDisksPartitionTypeInfoFlags = 8;
pub const UDISKS_PARTITION_TYPE_INFO_FLAGS_SYSTEM: UDisksPartitionTypeInfoFlags = 16;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_add_configuration_item: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut glib::GVariant, *mut glib::GVariant) -> gboolean>,
    pub handle_format: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_get_secret_configuration: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_open_for_backup: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut gio::GUnixFDList, *mut glib::GVariant) -> gboolean>,
    pub handle_open_for_benchmark: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut gio::GUnixFDList, *mut glib::GVariant) -> gboolean>,
    pub handle_open_for_restore: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut gio::GUnixFDList, *mut glib::GVariant) -> gboolean>,
    pub handle_remove_configuration_item: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut glib::GVariant, *mut glib::GVariant) -> gboolean>,
    pub handle_rescan: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_update_configuration_item: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut glib::GVariant, *mut glib::GVariant, *mut glib::GVariant) -> gboolean>,
    pub get_configuration: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *mut glib::GVariant>,
    pub get_crypto_backing_device: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_device: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_device_number: Option<unsafe extern "C" fn(*mut UDisksBlock) -> u64>,
    pub get_drive: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_hint_auto: Option<unsafe extern "C" fn(*mut UDisksBlock) -> gboolean>,
    pub get_hint_icon_name: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_hint_ignore: Option<unsafe extern "C" fn(*mut UDisksBlock) -> gboolean>,
    pub get_hint_name: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_hint_partitionable: Option<unsafe extern "C" fn(*mut UDisksBlock) -> gboolean>,
    pub get_hint_system: Option<unsafe extern "C" fn(*mut UDisksBlock) -> gboolean>,
    pub get_id_label: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_id_type: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_id_usage: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_id_uuid: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_id_version: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_preferred_device: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_read_only: Option<unsafe extern "C" fn(*mut UDisksBlock) -> gboolean>,
    pub get_size: Option<unsafe extern "C" fn(*mut UDisksBlock) -> u64>,
    pub get_symlinks: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const *const c_char>,
    pub get_userspace_mount_options: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const *const c_char>,
    pub get_hint_symbolic_icon_name: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_id: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_mdraid: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub get_mdraid_member: Option<unsafe extern "C" fn(*mut UDisksBlock) -> *const c_char>,
    pub handle_open_device: Option<unsafe extern "C" fn(*mut UDisksBlock, *mut gio::GDBusMethodInvocation, *mut gio::GUnixFDList, *const c_char, *mut glib::GVariant) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksBlockIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_add_configuration_item", &self.handle_add_configuration_item)
         .field("handle_format", &self.handle_format)
         .field("handle_get_secret_configuration", &self.handle_get_secret_configuration)
         .field("handle_open_for_backup", &self.handle_open_for_backup)
         .field("handle_open_for_benchmark", &self.handle_open_for_benchmark)
         .field("handle_open_for_restore", &self.handle_open_for_restore)
         .field("handle_remove_configuration_item", &self.handle_remove_configuration_item)
         .field("handle_rescan", &self.handle_rescan)
         .field("handle_update_configuration_item", &self.handle_update_configuration_item)
         .field("get_configuration", &self.get_configuration)
         .field("get_crypto_backing_device", &self.get_crypto_backing_device)
         .field("get_device", &self.get_device)
         .field("get_device_number", &self.get_device_number)
         .field("get_drive", &self.get_drive)
         .field("get_hint_auto", &self.get_hint_auto)
         .field("get_hint_icon_name", &self.get_hint_icon_name)
         .field("get_hint_ignore", &self.get_hint_ignore)
         .field("get_hint_name", &self.get_hint_name)
         .field("get_hint_partitionable", &self.get_hint_partitionable)
         .field("get_hint_system", &self.get_hint_system)
         .field("get_id_label", &self.get_id_label)
         .field("get_id_type", &self.get_id_type)
         .field("get_id_usage", &self.get_id_usage)
         .field("get_id_uuid", &self.get_id_uuid)
         .field("get_id_version", &self.get_id_version)
         .field("get_preferred_device", &self.get_preferred_device)
         .field("get_read_only", &self.get_read_only)
         .field("get_size", &self.get_size)
         .field("get_symlinks", &self.get_symlinks)
         .field("get_userspace_mount_options", &self.get_userspace_mount_options)
         .field("get_hint_symbolic_icon_name", &self.get_hint_symbolic_icon_name)
         .field("get_id", &self.get_id)
         .field("get_mdraid", &self.get_mdraid)
         .field("get_mdraid_member", &self.get_mdraid_member)
         .field("handle_open_device", &self.handle_open_device)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockLVM2Iface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_logical_volume: Option<unsafe extern "C" fn(*mut UDisksBlockLVM2) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksBlockLVM2Iface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockLVM2Iface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("get_logical_volume", &self.get_logical_volume)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockLVM2ProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksBlockLVM2ProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockLVM2ProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksBlockLVM2ProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksBlockLVM2ProxyPrivate = *mut _UDisksBlockLVM2ProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockLVM2SkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksBlockLVM2SkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockLVM2SkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksBlockLVM2SkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksBlockLVM2SkeletonPrivate = *mut _UDisksBlockLVM2SkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksBlockProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksBlockProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksBlockProxyPrivate = *mut _UDisksBlockProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksBlockSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksBlockSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksBlockSkeletonPrivate = *mut _UDisksBlockSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveAtaIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_pm_get_state: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_pm_standby: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_pm_wakeup: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_security_erase_unit: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_smart_get_attributes: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_smart_selftest_abort: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_smart_selftest_start: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_smart_update: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub get_aam_enabled: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_aam_supported: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_aam_vendor_recommended_value: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> c_int>,
    pub get_apm_enabled: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_apm_supported: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_pm_enabled: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_pm_supported: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_security_enhanced_erase_unit_minutes: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> c_int>,
    pub get_security_erase_unit_minutes: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> c_int>,
    pub get_security_frozen: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_smart_enabled: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_smart_failing: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_smart_num_attributes_failed_in_the_past: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> c_int>,
    pub get_smart_num_attributes_failing: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> c_int>,
    pub get_smart_num_bad_sectors: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> i64>,
    pub get_smart_power_on_seconds: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> u64>,
    pub get_smart_selftest_percent_remaining: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> c_int>,
    pub get_smart_selftest_status: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> *const c_char>,
    pub get_smart_supported: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_smart_temperature: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> c_double>,
    pub get_smart_updated: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> u64>,
    pub handle_smart_set_enabled: Option<unsafe extern "C" fn(*mut UDisksDriveAta, *mut gio::GDBusMethodInvocation, gboolean, *mut glib::GVariant) -> gboolean>,
    pub get_write_cache_enabled: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_write_cache_supported: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_read_lookahead_enabled: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
    pub get_read_lookahead_supported: Option<unsafe extern "C" fn(*mut UDisksDriveAta) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksDriveAtaIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveAtaIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_pm_get_state", &self.handle_pm_get_state)
         .field("handle_pm_standby", &self.handle_pm_standby)
         .field("handle_pm_wakeup", &self.handle_pm_wakeup)
         .field("handle_security_erase_unit", &self.handle_security_erase_unit)
         .field("handle_smart_get_attributes", &self.handle_smart_get_attributes)
         .field("handle_smart_selftest_abort", &self.handle_smart_selftest_abort)
         .field("handle_smart_selftest_start", &self.handle_smart_selftest_start)
         .field("handle_smart_update", &self.handle_smart_update)
         .field("get_aam_enabled", &self.get_aam_enabled)
         .field("get_aam_supported", &self.get_aam_supported)
         .field("get_aam_vendor_recommended_value", &self.get_aam_vendor_recommended_value)
         .field("get_apm_enabled", &self.get_apm_enabled)
         .field("get_apm_supported", &self.get_apm_supported)
         .field("get_pm_enabled", &self.get_pm_enabled)
         .field("get_pm_supported", &self.get_pm_supported)
         .field("get_security_enhanced_erase_unit_minutes", &self.get_security_enhanced_erase_unit_minutes)
         .field("get_security_erase_unit_minutes", &self.get_security_erase_unit_minutes)
         .field("get_security_frozen", &self.get_security_frozen)
         .field("get_smart_enabled", &self.get_smart_enabled)
         .field("get_smart_failing", &self.get_smart_failing)
         .field("get_smart_num_attributes_failed_in_the_past", &self.get_smart_num_attributes_failed_in_the_past)
         .field("get_smart_num_attributes_failing", &self.get_smart_num_attributes_failing)
         .field("get_smart_num_bad_sectors", &self.get_smart_num_bad_sectors)
         .field("get_smart_power_on_seconds", &self.get_smart_power_on_seconds)
         .field("get_smart_selftest_percent_remaining", &self.get_smart_selftest_percent_remaining)
         .field("get_smart_selftest_status", &self.get_smart_selftest_status)
         .field("get_smart_supported", &self.get_smart_supported)
         .field("get_smart_temperature", &self.get_smart_temperature)
         .field("get_smart_updated", &self.get_smart_updated)
         .field("handle_smart_set_enabled", &self.handle_smart_set_enabled)
         .field("get_write_cache_enabled", &self.get_write_cache_enabled)
         .field("get_write_cache_supported", &self.get_write_cache_supported)
         .field("get_read_lookahead_enabled", &self.get_read_lookahead_enabled)
         .field("get_read_lookahead_supported", &self.get_read_lookahead_supported)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveAtaProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksDriveAtaProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveAtaProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksDriveAtaProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksDriveAtaProxyPrivate = *mut _UDisksDriveAtaProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveAtaSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksDriveAtaSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveAtaSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksDriveAtaSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksDriveAtaSkeletonPrivate = *mut _UDisksDriveAtaSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_eject: Option<unsafe extern "C" fn(*mut UDisksDrive, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_set_configuration: Option<unsafe extern "C" fn(*mut UDisksDrive, *mut gio::GDBusMethodInvocation, *mut glib::GVariant, *mut glib::GVariant) -> gboolean>,
    pub get_configuration: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *mut glib::GVariant>,
    pub get_connection_bus: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_ejectable: Option<unsafe extern "C" fn(*mut UDisksDrive) -> gboolean>,
    pub get_id: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_media: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_media_available: Option<unsafe extern "C" fn(*mut UDisksDrive) -> gboolean>,
    pub get_media_change_detected: Option<unsafe extern "C" fn(*mut UDisksDrive) -> gboolean>,
    pub get_media_compatibility: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const *const c_char>,
    pub get_media_removable: Option<unsafe extern "C" fn(*mut UDisksDrive) -> gboolean>,
    pub get_model: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_optical: Option<unsafe extern "C" fn(*mut UDisksDrive) -> gboolean>,
    pub get_optical_blank: Option<unsafe extern "C" fn(*mut UDisksDrive) -> gboolean>,
    pub get_optical_num_audio_tracks: Option<unsafe extern "C" fn(*mut UDisksDrive) -> c_uint>,
    pub get_optical_num_data_tracks: Option<unsafe extern "C" fn(*mut UDisksDrive) -> c_uint>,
    pub get_optical_num_sessions: Option<unsafe extern "C" fn(*mut UDisksDrive) -> c_uint>,
    pub get_optical_num_tracks: Option<unsafe extern "C" fn(*mut UDisksDrive) -> c_uint>,
    pub get_removable: Option<unsafe extern "C" fn(*mut UDisksDrive) -> gboolean>,
    pub get_revision: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_rotation_rate: Option<unsafe extern "C" fn(*mut UDisksDrive) -> c_int>,
    pub get_seat: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_serial: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_size: Option<unsafe extern "C" fn(*mut UDisksDrive) -> u64>,
    pub get_sort_key: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_time_detected: Option<unsafe extern "C" fn(*mut UDisksDrive) -> u64>,
    pub get_time_media_detected: Option<unsafe extern "C" fn(*mut UDisksDrive) -> u64>,
    pub get_vendor: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub get_wwn: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
    pub handle_power_off: Option<unsafe extern "C" fn(*mut UDisksDrive, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub get_can_power_off: Option<unsafe extern "C" fn(*mut UDisksDrive) -> gboolean>,
    pub get_sibling_id: Option<unsafe extern "C" fn(*mut UDisksDrive) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksDriveIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_eject", &self.handle_eject)
         .field("handle_set_configuration", &self.handle_set_configuration)
         .field("get_configuration", &self.get_configuration)
         .field("get_connection_bus", &self.get_connection_bus)
         .field("get_ejectable", &self.get_ejectable)
         .field("get_id", &self.get_id)
         .field("get_media", &self.get_media)
         .field("get_media_available", &self.get_media_available)
         .field("get_media_change_detected", &self.get_media_change_detected)
         .field("get_media_compatibility", &self.get_media_compatibility)
         .field("get_media_removable", &self.get_media_removable)
         .field("get_model", &self.get_model)
         .field("get_optical", &self.get_optical)
         .field("get_optical_blank", &self.get_optical_blank)
         .field("get_optical_num_audio_tracks", &self.get_optical_num_audio_tracks)
         .field("get_optical_num_data_tracks", &self.get_optical_num_data_tracks)
         .field("get_optical_num_sessions", &self.get_optical_num_sessions)
         .field("get_optical_num_tracks", &self.get_optical_num_tracks)
         .field("get_removable", &self.get_removable)
         .field("get_revision", &self.get_revision)
         .field("get_rotation_rate", &self.get_rotation_rate)
         .field("get_seat", &self.get_seat)
         .field("get_serial", &self.get_serial)
         .field("get_size", &self.get_size)
         .field("get_sort_key", &self.get_sort_key)
         .field("get_time_detected", &self.get_time_detected)
         .field("get_time_media_detected", &self.get_time_media_detected)
         .field("get_vendor", &self.get_vendor)
         .field("get_wwn", &self.get_wwn)
         .field("handle_power_off", &self.handle_power_off)
         .field("get_can_power_off", &self.get_can_power_off)
         .field("get_sibling_id", &self.get_sibling_id)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksDriveProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksDriveProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksDriveProxyPrivate = *mut _UDisksDriveProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksDriveSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksDriveSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksDriveSkeletonPrivate = *mut _UDisksDriveSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksEncryptedIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_change_passphrase: Option<unsafe extern "C" fn(*mut UDisksEncrypted, *mut gio::GDBusMethodInvocation, *const c_char, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_lock: Option<unsafe extern "C" fn(*mut UDisksEncrypted, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_unlock: Option<unsafe extern "C" fn(*mut UDisksEncrypted, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub get_child_configuration: Option<unsafe extern "C" fn(*mut UDisksEncrypted) -> *mut glib::GVariant>,
    pub get_cleartext_device: Option<unsafe extern "C" fn(*mut UDisksEncrypted) -> *const c_char>,
    pub get_hint_encryption_type: Option<unsafe extern "C" fn(*mut UDisksEncrypted) -> *const c_char>,
    pub get_metadata_size: Option<unsafe extern "C" fn(*mut UDisksEncrypted) -> u64>,
    pub handle_resize: Option<unsafe extern "C" fn(*mut UDisksEncrypted, *mut gio::GDBusMethodInvocation, u64, *mut glib::GVariant) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksEncryptedIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksEncryptedIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_change_passphrase", &self.handle_change_passphrase)
         .field("handle_lock", &self.handle_lock)
         .field("handle_unlock", &self.handle_unlock)
         .field("get_child_configuration", &self.get_child_configuration)
         .field("get_cleartext_device", &self.get_cleartext_device)
         .field("get_hint_encryption_type", &self.get_hint_encryption_type)
         .field("get_metadata_size", &self.get_metadata_size)
         .field("handle_resize", &self.handle_resize)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksEncryptedProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksEncryptedProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksEncryptedProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksEncryptedProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksEncryptedProxyPrivate = *mut _UDisksEncryptedProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksEncryptedSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksEncryptedSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksEncryptedSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksEncryptedSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksEncryptedSkeletonPrivate = *mut _UDisksEncryptedSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemBTRFSIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_create_snapshot: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, *const c_char, *const c_char, gboolean, *mut glib::GVariant) -> gboolean>,
    pub handle_create_subvolume: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_get_subvolumes: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, gboolean, *mut glib::GVariant) -> gboolean>,
    pub handle_remove_subvolume: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_set_label: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub get_label: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS) -> *const c_char>,
    pub get_num_devices: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS) -> u64>,
    pub get_used: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS) -> u64>,
    pub get_uuid: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS) -> *const c_char>,
    pub handle_add_device: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_remove_device: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_repair: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_resize: Option<unsafe extern "C" fn(*mut UDisksFilesystemBTRFS, *mut gio::GDBusMethodInvocation, u64, *mut glib::GVariant) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksFilesystemBTRFSIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemBTRFSIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_create_snapshot", &self.handle_create_snapshot)
         .field("handle_create_subvolume", &self.handle_create_subvolume)
         .field("handle_get_subvolumes", &self.handle_get_subvolumes)
         .field("handle_remove_subvolume", &self.handle_remove_subvolume)
         .field("handle_set_label", &self.handle_set_label)
         .field("get_label", &self.get_label)
         .field("get_num_devices", &self.get_num_devices)
         .field("get_used", &self.get_used)
         .field("get_uuid", &self.get_uuid)
         .field("handle_add_device", &self.handle_add_device)
         .field("handle_remove_device", &self.handle_remove_device)
         .field("handle_repair", &self.handle_repair)
         .field("handle_resize", &self.handle_resize)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemBTRFSProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksFilesystemBTRFSProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemBTRFSProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksFilesystemBTRFSProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksFilesystemBTRFSProxyPrivate = *mut _UDisksFilesystemBTRFSProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemBTRFSSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksFilesystemBTRFSSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemBTRFSSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksFilesystemBTRFSSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksFilesystemBTRFSSkeletonPrivate = *mut _UDisksFilesystemBTRFSSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_mount: Option<unsafe extern "C" fn(*mut UDisksFilesystem, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_set_label: Option<unsafe extern "C" fn(*mut UDisksFilesystem, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_unmount: Option<unsafe extern "C" fn(*mut UDisksFilesystem, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub get_mount_points: Option<unsafe extern "C" fn(*mut UDisksFilesystem) -> *const *const c_char>,
    pub get_size: Option<unsafe extern "C" fn(*mut UDisksFilesystem) -> u64>,
    pub handle_check: Option<unsafe extern "C" fn(*mut UDisksFilesystem, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_repair: Option<unsafe extern "C" fn(*mut UDisksFilesystem, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_resize: Option<unsafe extern "C" fn(*mut UDisksFilesystem, *mut gio::GDBusMethodInvocation, u64, *mut glib::GVariant) -> gboolean>,
    pub handle_take_ownership: Option<unsafe extern "C" fn(*mut UDisksFilesystem, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksFilesystemIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_mount", &self.handle_mount)
         .field("handle_set_label", &self.handle_set_label)
         .field("handle_unmount", &self.handle_unmount)
         .field("get_mount_points", &self.get_mount_points)
         .field("get_size", &self.get_size)
         .field("handle_check", &self.handle_check)
         .field("handle_repair", &self.handle_repair)
         .field("handle_resize", &self.handle_resize)
         .field("handle_take_ownership", &self.handle_take_ownership)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksFilesystemProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksFilesystemProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksFilesystemProxyPrivate = *mut _UDisksFilesystemProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksFilesystemSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksFilesystemSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksFilesystemSkeletonPrivate = *mut _UDisksFilesystemSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksJobIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_cancel: Option<unsafe extern "C" fn(*mut UDisksJob, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub get_cancelable: Option<unsafe extern "C" fn(*mut UDisksJob) -> gboolean>,
    pub get_expected_end_time: Option<unsafe extern "C" fn(*mut UDisksJob) -> u64>,
    pub get_objects: Option<unsafe extern "C" fn(*mut UDisksJob) -> *const *const c_char>,
    pub get_operation: Option<unsafe extern "C" fn(*mut UDisksJob) -> *const c_char>,
    pub get_progress: Option<unsafe extern "C" fn(*mut UDisksJob) -> c_double>,
    pub get_progress_valid: Option<unsafe extern "C" fn(*mut UDisksJob) -> gboolean>,
    pub get_start_time: Option<unsafe extern "C" fn(*mut UDisksJob) -> u64>,
    pub get_started_by_uid: Option<unsafe extern "C" fn(*mut UDisksJob) -> c_uint>,
    pub completed: Option<unsafe extern "C" fn(*mut UDisksJob, gboolean, *const c_char)>,
    pub get_bytes: Option<unsafe extern "C" fn(*mut UDisksJob) -> u64>,
    pub get_rate: Option<unsafe extern "C" fn(*mut UDisksJob) -> u64>,
}

impl ::std::fmt::Debug for UDisksJobIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksJobIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_cancel", &self.handle_cancel)
         .field("get_cancelable", &self.get_cancelable)
         .field("get_expected_end_time", &self.get_expected_end_time)
         .field("get_objects", &self.get_objects)
         .field("get_operation", &self.get_operation)
         .field("get_progress", &self.get_progress)
         .field("get_progress_valid", &self.get_progress_valid)
         .field("get_start_time", &self.get_start_time)
         .field("get_started_by_uid", &self.get_started_by_uid)
         .field("completed", &self.completed)
         .field("get_bytes", &self.get_bytes)
         .field("get_rate", &self.get_rate)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksJobProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksJobProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksJobProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksJobProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksJobProxyPrivate = *mut _UDisksJobProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksJobSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksJobSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksJobSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksJobSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksJobSkeletonPrivate = *mut _UDisksJobSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLogicalVolumeIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_activate: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_create_snapshot: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, *const c_char, u64, *mut glib::GVariant) -> gboolean>,
    pub handle_deactivate: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_delete: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_rename: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_resize: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, u64, *mut glib::GVariant) -> gboolean>,
    pub get_active: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> gboolean>,
    pub get_child_configuration: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> *mut glib::GVariant>,
    pub get_data_allocated_ratio: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> c_double>,
    pub get_metadata_allocated_ratio: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> c_double>,
    pub get_name: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> *const c_char>,
    pub get_origin: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> *const c_char>,
    pub get_size: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> u64>,
    pub get_thin_pool: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> *const c_char>,
    pub get_type_: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> *const c_char>,
    pub get_uuid: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> *const c_char>,
    pub get_volume_group: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> *const c_char>,
    pub handle_cache_attach: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_cache_split: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_cache_detach: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub get_block_device: Option<unsafe extern "C" fn(*mut UDisksLogicalVolume) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksLogicalVolumeIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLogicalVolumeIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_activate", &self.handle_activate)
         .field("handle_create_snapshot", &self.handle_create_snapshot)
         .field("handle_deactivate", &self.handle_deactivate)
         .field("handle_delete", &self.handle_delete)
         .field("handle_rename", &self.handle_rename)
         .field("handle_resize", &self.handle_resize)
         .field("get_active", &self.get_active)
         .field("get_child_configuration", &self.get_child_configuration)
         .field("get_data_allocated_ratio", &self.get_data_allocated_ratio)
         .field("get_metadata_allocated_ratio", &self.get_metadata_allocated_ratio)
         .field("get_name", &self.get_name)
         .field("get_origin", &self.get_origin)
         .field("get_size", &self.get_size)
         .field("get_thin_pool", &self.get_thin_pool)
         .field("get_type_", &self.get_type_)
         .field("get_uuid", &self.get_uuid)
         .field("get_volume_group", &self.get_volume_group)
         .field("handle_cache_attach", &self.handle_cache_attach)
         .field("handle_cache_split", &self.handle_cache_split)
         .field("handle_cache_detach", &self.handle_cache_detach)
         .field("get_block_device", &self.get_block_device)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLogicalVolumeProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksLogicalVolumeProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLogicalVolumeProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksLogicalVolumeProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksLogicalVolumeProxyPrivate = *mut _UDisksLogicalVolumeProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLogicalVolumeSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksLogicalVolumeSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLogicalVolumeSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksLogicalVolumeSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksLogicalVolumeSkeletonPrivate = *mut _UDisksLogicalVolumeSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLoopIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_delete: Option<unsafe extern "C" fn(*mut UDisksLoop, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_set_autoclear: Option<unsafe extern "C" fn(*mut UDisksLoop, *mut gio::GDBusMethodInvocation, gboolean, *mut glib::GVariant) -> gboolean>,
    pub get_autoclear: Option<unsafe extern "C" fn(*mut UDisksLoop) -> gboolean>,
    pub get_backing_file: Option<unsafe extern "C" fn(*mut UDisksLoop) -> *const c_char>,
    pub get_setup_by_uid: Option<unsafe extern "C" fn(*mut UDisksLoop) -> c_uint>,
}

impl ::std::fmt::Debug for UDisksLoopIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLoopIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_delete", &self.handle_delete)
         .field("handle_set_autoclear", &self.handle_set_autoclear)
         .field("get_autoclear", &self.get_autoclear)
         .field("get_backing_file", &self.get_backing_file)
         .field("get_setup_by_uid", &self.get_setup_by_uid)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLoopProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksLoopProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLoopProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksLoopProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksLoopProxyPrivate = *mut _UDisksLoopProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLoopSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksLoopSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLoopSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksLoopSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksLoopSkeletonPrivate = *mut _UDisksLoopSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksMDRaidIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_add_device: Option<unsafe extern "C" fn(*mut UDisksMDRaid, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_delete: Option<unsafe extern "C" fn(*mut UDisksMDRaid, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_remove_device: Option<unsafe extern "C" fn(*mut UDisksMDRaid, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_request_sync_action: Option<unsafe extern "C" fn(*mut UDisksMDRaid, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_set_bitmap_location: Option<unsafe extern "C" fn(*mut UDisksMDRaid, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_start: Option<unsafe extern "C" fn(*mut UDisksMDRaid, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_stop: Option<unsafe extern "C" fn(*mut UDisksMDRaid, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub get_active_devices: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> *mut glib::GVariant>,
    pub get_bitmap_location: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> *const c_char>,
    pub get_child_configuration: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> *mut glib::GVariant>,
    pub get_chunk_size: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> u64>,
    pub get_degraded: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> c_uint>,
    pub get_level: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> *const c_char>,
    pub get_name: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> *const c_char>,
    pub get_num_devices: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> c_uint>,
    pub get_running: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> gboolean>,
    pub get_size: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> u64>,
    pub get_sync_action: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> *const c_char>,
    pub get_sync_completed: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> c_double>,
    pub get_sync_rate: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> u64>,
    pub get_sync_remaining_time: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> u64>,
    pub get_uuid: Option<unsafe extern "C" fn(*mut UDisksMDRaid) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksMDRaidIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksMDRaidIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_add_device", &self.handle_add_device)
         .field("handle_delete", &self.handle_delete)
         .field("handle_remove_device", &self.handle_remove_device)
         .field("handle_request_sync_action", &self.handle_request_sync_action)
         .field("handle_set_bitmap_location", &self.handle_set_bitmap_location)
         .field("handle_start", &self.handle_start)
         .field("handle_stop", &self.handle_stop)
         .field("get_active_devices", &self.get_active_devices)
         .field("get_bitmap_location", &self.get_bitmap_location)
         .field("get_child_configuration", &self.get_child_configuration)
         .field("get_chunk_size", &self.get_chunk_size)
         .field("get_degraded", &self.get_degraded)
         .field("get_level", &self.get_level)
         .field("get_name", &self.get_name)
         .field("get_num_devices", &self.get_num_devices)
         .field("get_running", &self.get_running)
         .field("get_size", &self.get_size)
         .field("get_sync_action", &self.get_sync_action)
         .field("get_sync_completed", &self.get_sync_completed)
         .field("get_sync_rate", &self.get_sync_rate)
         .field("get_sync_remaining_time", &self.get_sync_remaining_time)
         .field("get_uuid", &self.get_uuid)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksMDRaidProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksMDRaidProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksMDRaidProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksMDRaidProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksMDRaidProxyPrivate = *mut _UDisksMDRaidProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksMDRaidSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksMDRaidSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksMDRaidSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksMDRaidSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksMDRaidSkeletonPrivate = *mut _UDisksMDRaidSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerBTRFSIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_create_volume: Option<unsafe extern "C" fn(*mut UDisksManagerBTRFS, *mut gio::GDBusMethodInvocation, *const *const c_char, *const c_char, *const c_char, *const c_char, *mut glib::GVariant) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksManagerBTRFSIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerBTRFSIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_create_volume", &self.handle_create_volume)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerBTRFSProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksManagerBTRFSProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerBTRFSProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksManagerBTRFSProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksManagerBTRFSProxyPrivate = *mut _UDisksManagerBTRFSProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerBTRFSSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksManagerBTRFSSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerBTRFSSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksManagerBTRFSSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksManagerBTRFSSkeletonPrivate = *mut _UDisksManagerBTRFSSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_enable_modules: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, gboolean) -> gboolean>,
    pub handle_loop_setup: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *mut gio::GUnixFDList, *mut glib::GVariant, *mut glib::GVariant) -> gboolean>,
    pub get_default_encryption_type: Option<unsafe extern "C" fn(*mut UDisksManager) -> *const c_char>,
    pub get_supported_encryption_types: Option<unsafe extern "C" fn(*mut UDisksManager) -> *const *const c_char>,
    pub get_supported_filesystems: Option<unsafe extern "C" fn(*mut UDisksManager) -> *const *const c_char>,
    pub get_version: Option<unsafe extern "C" fn(*mut UDisksManager) -> *const c_char>,
    pub handle_mdraid_create: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *const *const c_char, *const c_char, *const c_char, u64, *mut glib::GVariant) -> gboolean>,
    pub handle_can_check: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *const c_char) -> gboolean>,
    pub handle_can_format: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *const c_char) -> gboolean>,
    pub handle_can_repair: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *const c_char) -> gboolean>,
    pub handle_can_resize: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *const c_char) -> gboolean>,
    pub handle_get_block_devices: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_resolve_device: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *mut glib::GVariant, *mut glib::GVariant) -> gboolean>,
    pub handle_enable_module: Option<unsafe extern "C" fn(*mut UDisksManager, *mut gio::GDBusMethodInvocation, *const c_char, gboolean) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksManagerIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_enable_modules", &self.handle_enable_modules)
         .field("handle_loop_setup", &self.handle_loop_setup)
         .field("get_default_encryption_type", &self.get_default_encryption_type)
         .field("get_supported_encryption_types", &self.get_supported_encryption_types)
         .field("get_supported_filesystems", &self.get_supported_filesystems)
         .field("get_version", &self.get_version)
         .field("handle_mdraid_create", &self.handle_mdraid_create)
         .field("handle_can_check", &self.handle_can_check)
         .field("handle_can_format", &self.handle_can_format)
         .field("handle_can_repair", &self.handle_can_repair)
         .field("handle_can_resize", &self.handle_can_resize)
         .field("handle_get_block_devices", &self.handle_get_block_devices)
         .field("handle_resolve_device", &self.handle_resolve_device)
         .field("handle_enable_module", &self.handle_enable_module)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerLVM2Iface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_volume_group_create: Option<unsafe extern "C" fn(*mut UDisksManagerLVM2, *mut gio::GDBusMethodInvocation, *const c_char, *const *const c_char, *mut glib::GVariant) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksManagerLVM2Iface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerLVM2Iface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_volume_group_create", &self.handle_volume_group_create)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerLVM2ProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksManagerLVM2ProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerLVM2ProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksManagerLVM2ProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksManagerLVM2ProxyPrivate = *mut _UDisksManagerLVM2ProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerLVM2SkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksManagerLVM2SkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerLVM2SkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksManagerLVM2SkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksManagerLVM2SkeletonPrivate = *mut _UDisksManagerLVM2SkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksManagerProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksManagerProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksManagerProxyPrivate = *mut _UDisksManagerProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksManagerSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksManagerSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksManagerSkeletonPrivate = *mut _UDisksManagerSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksObjectIface {
    pub parent_iface: gobject::GTypeInterface,
}

impl ::std::fmt::Debug for UDisksObjectIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksObjectIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksObjectManagerClientClass {
    pub parent_class: gio::GDBusObjectManagerClientClass,
}

impl ::std::fmt::Debug for UDisksObjectManagerClientClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksObjectManagerClientClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksObjectManagerClientPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksObjectManagerClientPrivate = *mut _UDisksObjectManagerClientPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksObjectProxyClass {
    pub parent_class: gio::GDBusObjectProxyClass,
}

impl ::std::fmt::Debug for UDisksObjectProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksObjectProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksObjectProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksObjectProxyPrivate = *mut _UDisksObjectProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksObjectSkeletonClass {
    pub parent_class: gio::GDBusObjectSkeletonClass,
}

impl ::std::fmt::Debug for UDisksObjectSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksObjectSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksObjectSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksObjectSkeletonPrivate = *mut _UDisksObjectSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_delete: Option<unsafe extern "C" fn(*mut UDisksPartition, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_resize: Option<unsafe extern "C" fn(*mut UDisksPartition, *mut gio::GDBusMethodInvocation, u64, *mut glib::GVariant) -> gboolean>,
    pub handle_set_flags: Option<unsafe extern "C" fn(*mut UDisksPartition, *mut gio::GDBusMethodInvocation, u64, *mut glib::GVariant) -> gboolean>,
    pub handle_set_name: Option<unsafe extern "C" fn(*mut UDisksPartition, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_set_type: Option<unsafe extern "C" fn(*mut UDisksPartition, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub get_flags: Option<unsafe extern "C" fn(*mut UDisksPartition) -> u64>,
    pub get_is_contained: Option<unsafe extern "C" fn(*mut UDisksPartition) -> gboolean>,
    pub get_is_container: Option<unsafe extern "C" fn(*mut UDisksPartition) -> gboolean>,
    pub get_name: Option<unsafe extern "C" fn(*mut UDisksPartition) -> *const c_char>,
    pub get_number: Option<unsafe extern "C" fn(*mut UDisksPartition) -> c_uint>,
    pub get_offset: Option<unsafe extern "C" fn(*mut UDisksPartition) -> u64>,
    pub get_size: Option<unsafe extern "C" fn(*mut UDisksPartition) -> u64>,
    pub get_table: Option<unsafe extern "C" fn(*mut UDisksPartition) -> *const c_char>,
    pub get_type_: Option<unsafe extern "C" fn(*mut UDisksPartition) -> *const c_char>,
    pub get_uuid: Option<unsafe extern "C" fn(*mut UDisksPartition) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksPartitionIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_delete", &self.handle_delete)
         .field("handle_resize", &self.handle_resize)
         .field("handle_set_flags", &self.handle_set_flags)
         .field("handle_set_name", &self.handle_set_name)
         .field("handle_set_type", &self.handle_set_type)
         .field("get_flags", &self.get_flags)
         .field("get_is_contained", &self.get_is_contained)
         .field("get_is_container", &self.get_is_container)
         .field("get_name", &self.get_name)
         .field("get_number", &self.get_number)
         .field("get_offset", &self.get_offset)
         .field("get_size", &self.get_size)
         .field("get_table", &self.get_table)
         .field("get_type_", &self.get_type_)
         .field("get_uuid", &self.get_uuid)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksPartitionProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksPartitionProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksPartitionProxyPrivate = *mut _UDisksPartitionProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksPartitionSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksPartitionSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksPartitionSkeletonPrivate = *mut _UDisksPartitionSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionTableIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_create_partition: Option<unsafe extern "C" fn(*mut UDisksPartitionTable, *mut gio::GDBusMethodInvocation, u64, u64, *const c_char, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_create_partition_and_format: Option<unsafe extern "C" fn(*mut UDisksPartitionTable, *mut gio::GDBusMethodInvocation, u64, u64, *const c_char, *const c_char, *mut glib::GVariant, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub get_partitions: Option<unsafe extern "C" fn(*mut UDisksPartitionTable) -> *const *const c_char>,
    pub get_type_: Option<unsafe extern "C" fn(*mut UDisksPartitionTable) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksPartitionTableIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionTableIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_create_partition", &self.handle_create_partition)
         .field("handle_create_partition_and_format", &self.handle_create_partition_and_format)
         .field("get_partitions", &self.get_partitions)
         .field("get_type_", &self.get_type_)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionTableProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksPartitionTableProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionTableProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksPartitionTableProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksPartitionTableProxyPrivate = *mut _UDisksPartitionTableProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionTableSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksPartitionTableSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionTableSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksPartitionTableSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksPartitionTableSkeletonPrivate = *mut _UDisksPartitionTableSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionTypeInfo {
    pub table_type: *const c_char,
    pub table_subtype: *const c_char,
    pub type_: *const c_char,
    pub flags: UDisksPartitionTypeInfoFlags,
}

impl ::std::fmt::Debug for UDisksPartitionTypeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionTypeInfo @ {self:p}"))
         .field("table_type", &self.table_type)
         .field("table_subtype", &self.table_subtype)
         .field("type_", &self.type_)
         .field("flags", &self.flags)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPhysicalVolumeIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_free_size: Option<unsafe extern "C" fn(*mut UDisksPhysicalVolume) -> u64>,
    pub get_size: Option<unsafe extern "C" fn(*mut UDisksPhysicalVolume) -> u64>,
    pub get_volume_group: Option<unsafe extern "C" fn(*mut UDisksPhysicalVolume) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksPhysicalVolumeIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPhysicalVolumeIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("get_free_size", &self.get_free_size)
         .field("get_size", &self.get_size)
         .field("get_volume_group", &self.get_volume_group)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPhysicalVolumeProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksPhysicalVolumeProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPhysicalVolumeProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksPhysicalVolumeProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksPhysicalVolumeProxyPrivate = *mut _UDisksPhysicalVolumeProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPhysicalVolumeSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksPhysicalVolumeSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPhysicalVolumeSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksPhysicalVolumeSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksPhysicalVolumeSkeletonPrivate = *mut _UDisksPhysicalVolumeSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksSwapspaceIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_set_label: Option<unsafe extern "C" fn(*mut UDisksSwapspace, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_start: Option<unsafe extern "C" fn(*mut UDisksSwapspace, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_stop: Option<unsafe extern "C" fn(*mut UDisksSwapspace, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub get_active: Option<unsafe extern "C" fn(*mut UDisksSwapspace) -> gboolean>,
}

impl ::std::fmt::Debug for UDisksSwapspaceIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksSwapspaceIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_set_label", &self.handle_set_label)
         .field("handle_start", &self.handle_start)
         .field("handle_stop", &self.handle_stop)
         .field("get_active", &self.get_active)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksSwapspaceProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksSwapspaceProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksSwapspaceProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksSwapspaceProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksSwapspaceProxyPrivate = *mut _UDisksSwapspaceProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksSwapspaceSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksSwapspaceSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksSwapspaceSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksSwapspaceSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksSwapspaceSkeletonPrivate = *mut _UDisksSwapspaceSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVDOVolumeIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_enable_compression: Option<unsafe extern "C" fn(*mut UDisksVDOVolume, *mut gio::GDBusMethodInvocation, gboolean, *mut glib::GVariant) -> gboolean>,
    pub handle_enable_deduplication: Option<unsafe extern "C" fn(*mut UDisksVDOVolume, *mut gio::GDBusMethodInvocation, gboolean, *mut glib::GVariant) -> gboolean>,
    pub handle_get_statistics: Option<unsafe extern "C" fn(*mut UDisksVDOVolume, *mut gio::GDBusMethodInvocation, *mut glib::GVariant) -> gboolean>,
    pub handle_resize_logical: Option<unsafe extern "C" fn(*mut UDisksVDOVolume, *mut gio::GDBusMethodInvocation, u64, *mut glib::GVariant) -> gboolean>,
    pub handle_resize_physical: Option<unsafe extern "C" fn(*mut UDisksVDOVolume, *mut gio::GDBusMethodInvocation, u64, *mut glib::GVariant) -> gboolean>,
    pub get_compression: Option<unsafe extern "C" fn(*mut UDisksVDOVolume) -> gboolean>,
    pub get_compression_state: Option<unsafe extern "C" fn(*mut UDisksVDOVolume) -> *const c_char>,
    pub get_deduplication: Option<unsafe extern "C" fn(*mut UDisksVDOVolume) -> gboolean>,
    pub get_index_state: Option<unsafe extern "C" fn(*mut UDisksVDOVolume) -> *const c_char>,
    pub get_operating_mode: Option<unsafe extern "C" fn(*mut UDisksVDOVolume) -> *const c_char>,
    pub get_used_size: Option<unsafe extern "C" fn(*mut UDisksVDOVolume) -> u64>,
    pub get_vdo_pool: Option<unsafe extern "C" fn(*mut UDisksVDOVolume) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksVDOVolumeIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVDOVolumeIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_enable_compression", &self.handle_enable_compression)
         .field("handle_enable_deduplication", &self.handle_enable_deduplication)
         .field("handle_get_statistics", &self.handle_get_statistics)
         .field("handle_resize_logical", &self.handle_resize_logical)
         .field("handle_resize_physical", &self.handle_resize_physical)
         .field("get_compression", &self.get_compression)
         .field("get_compression_state", &self.get_compression_state)
         .field("get_deduplication", &self.get_deduplication)
         .field("get_index_state", &self.get_index_state)
         .field("get_operating_mode", &self.get_operating_mode)
         .field("get_used_size", &self.get_used_size)
         .field("get_vdo_pool", &self.get_vdo_pool)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVDOVolumeProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksVDOVolumeProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVDOVolumeProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksVDOVolumeProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksVDOVolumeProxyPrivate = *mut _UDisksVDOVolumeProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVDOVolumeSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksVDOVolumeSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVDOVolumeSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksVDOVolumeSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksVDOVolumeSkeletonPrivate = *mut _UDisksVDOVolumeSkeletonPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVolumeGroupIface {
    pub parent_iface: gobject::GTypeInterface,
    pub handle_add_device: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_create_plain_volume: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, *const c_char, u64, *mut glib::GVariant) -> gboolean>,
    pub handle_create_thin_pool_volume: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, *const c_char, u64, *mut glib::GVariant) -> gboolean>,
    pub handle_create_thin_volume: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, *const c_char, u64, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_create_vdo_volume: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, *const c_char, *const c_char, u64, u64, u64, gboolean, gboolean, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_delete: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, gboolean, *mut glib::GVariant) -> gboolean>,
    pub handle_empty_device: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub handle_poll: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation) -> gboolean>,
    pub handle_remove_device: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, *const c_char, gboolean, *mut glib::GVariant) -> gboolean>,
    pub handle_rename: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup, *mut gio::GDBusMethodInvocation, *const c_char, *mut glib::GVariant) -> gboolean>,
    pub get_extent_size: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup) -> u64>,
    pub get_free_size: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup) -> u64>,
    pub get_name: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup) -> *const c_char>,
    pub get_needs_polling: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup) -> gboolean>,
    pub get_size: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup) -> u64>,
    pub get_uuid: Option<unsafe extern "C" fn(*mut UDisksVolumeGroup) -> *const c_char>,
}

impl ::std::fmt::Debug for UDisksVolumeGroupIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVolumeGroupIface @ {self:p}"))
         .field("parent_iface", &self.parent_iface)
         .field("handle_add_device", &self.handle_add_device)
         .field("handle_create_plain_volume", &self.handle_create_plain_volume)
         .field("handle_create_thin_pool_volume", &self.handle_create_thin_pool_volume)
         .field("handle_create_thin_volume", &self.handle_create_thin_volume)
         .field("handle_create_vdo_volume", &self.handle_create_vdo_volume)
         .field("handle_delete", &self.handle_delete)
         .field("handle_empty_device", &self.handle_empty_device)
         .field("handle_poll", &self.handle_poll)
         .field("handle_remove_device", &self.handle_remove_device)
         .field("handle_rename", &self.handle_rename)
         .field("get_extent_size", &self.get_extent_size)
         .field("get_free_size", &self.get_free_size)
         .field("get_name", &self.get_name)
         .field("get_needs_polling", &self.get_needs_polling)
         .field("get_size", &self.get_size)
         .field("get_uuid", &self.get_uuid)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVolumeGroupProxyClass {
    pub parent_class: gio::GDBusProxyClass,
}

impl ::std::fmt::Debug for UDisksVolumeGroupProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVolumeGroupProxyClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksVolumeGroupProxyPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksVolumeGroupProxyPrivate = *mut _UDisksVolumeGroupProxyPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVolumeGroupSkeletonClass {
    pub parent_class: gio::GDBusInterfaceSkeletonClass,
}

impl ::std::fmt::Debug for UDisksVolumeGroupSkeletonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVolumeGroupSkeletonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct _UDisksVolumeGroupSkeletonPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UDisksVolumeGroupSkeletonPrivate = *mut _UDisksVolumeGroupSkeletonPrivate;

// Classes
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockLVM2Proxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksBlockLVM2ProxyPrivate,
}

impl ::std::fmt::Debug for UDisksBlockLVM2Proxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockLVM2Proxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockLVM2Skeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksBlockLVM2SkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksBlockLVM2Skeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockLVM2Skeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksBlockProxyPrivate,
}

impl ::std::fmt::Debug for UDisksBlockProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksBlockSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksBlockSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksBlockSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksBlockSkeleton @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct UDisksClient {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksClient @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveAtaProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksDriveAtaProxyPrivate,
}

impl ::std::fmt::Debug for UDisksDriveAtaProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveAtaProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveAtaSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksDriveAtaSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksDriveAtaSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveAtaSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksDriveProxyPrivate,
}

impl ::std::fmt::Debug for UDisksDriveProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksDriveSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksDriveSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksDriveSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksDriveSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksEncryptedProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksEncryptedProxyPrivate,
}

impl ::std::fmt::Debug for UDisksEncryptedProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksEncryptedProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksEncryptedSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksEncryptedSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksEncryptedSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksEncryptedSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemBTRFSProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksFilesystemBTRFSProxyPrivate,
}

impl ::std::fmt::Debug for UDisksFilesystemBTRFSProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemBTRFSProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemBTRFSSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksFilesystemBTRFSSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksFilesystemBTRFSSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemBTRFSSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksFilesystemProxyPrivate,
}

impl ::std::fmt::Debug for UDisksFilesystemProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksFilesystemSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksFilesystemSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksFilesystemSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksFilesystemSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksJobProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksJobProxyPrivate,
}

impl ::std::fmt::Debug for UDisksJobProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksJobProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksJobSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksJobSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksJobSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksJobSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLogicalVolumeProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksLogicalVolumeProxyPrivate,
}

impl ::std::fmt::Debug for UDisksLogicalVolumeProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLogicalVolumeProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLogicalVolumeSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksLogicalVolumeSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksLogicalVolumeSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLogicalVolumeSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLoopProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksLoopProxyPrivate,
}

impl ::std::fmt::Debug for UDisksLoopProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLoopProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksLoopSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksLoopSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksLoopSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksLoopSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksMDRaidProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksMDRaidProxyPrivate,
}

impl ::std::fmt::Debug for UDisksMDRaidProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksMDRaidProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksMDRaidSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksMDRaidSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksMDRaidSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksMDRaidSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerBTRFSProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksManagerBTRFSProxyPrivate,
}

impl ::std::fmt::Debug for UDisksManagerBTRFSProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerBTRFSProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerBTRFSSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksManagerBTRFSSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksManagerBTRFSSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerBTRFSSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerLVM2Proxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksManagerLVM2ProxyPrivate,
}

impl ::std::fmt::Debug for UDisksManagerLVM2Proxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerLVM2Proxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerLVM2Skeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksManagerLVM2SkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksManagerLVM2Skeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerLVM2Skeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksManagerProxyPrivate,
}

impl ::std::fmt::Debug for UDisksManagerProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksManagerSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksManagerSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksManagerSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksManagerSkeleton @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct UDisksObjectInfo {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksObjectInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksObjectInfo @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksObjectManagerClient {
    pub parent_instance: gio::GDBusObjectManagerClient,
    pub priv_: *mut UDisksObjectManagerClientPrivate,
}

impl ::std::fmt::Debug for UDisksObjectManagerClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksObjectManagerClient @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksObjectProxy {
    pub parent_instance: gio::GDBusObjectProxy,
    pub priv_: *mut UDisksObjectProxyPrivate,
}

impl ::std::fmt::Debug for UDisksObjectProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksObjectProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksObjectSkeleton {
    pub parent_instance: gio::GDBusObjectSkeleton,
    pub priv_: *mut UDisksObjectSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksObjectSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksObjectSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksPartitionProxyPrivate,
}

impl ::std::fmt::Debug for UDisksPartitionProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksPartitionSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksPartitionSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionTableProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksPartitionTableProxyPrivate,
}

impl ::std::fmt::Debug for UDisksPartitionTableProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionTableProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPartitionTableSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksPartitionTableSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksPartitionTableSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPartitionTableSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPhysicalVolumeProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksPhysicalVolumeProxyPrivate,
}

impl ::std::fmt::Debug for UDisksPhysicalVolumeProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPhysicalVolumeProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksPhysicalVolumeSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksPhysicalVolumeSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksPhysicalVolumeSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksPhysicalVolumeSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksSwapspaceProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksSwapspaceProxyPrivate,
}

impl ::std::fmt::Debug for UDisksSwapspaceProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksSwapspaceProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksSwapspaceSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksSwapspaceSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksSwapspaceSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksSwapspaceSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVDOVolumeProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksVDOVolumeProxyPrivate,
}

impl ::std::fmt::Debug for UDisksVDOVolumeProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVDOVolumeProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVDOVolumeSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksVDOVolumeSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksVDOVolumeSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVDOVolumeSkeleton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVolumeGroupProxy {
    pub parent_instance: gio::GDBusProxy,
    pub priv_: *mut UDisksVolumeGroupProxyPrivate,
}

impl ::std::fmt::Debug for UDisksVolumeGroupProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVolumeGroupProxy @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UDisksVolumeGroupSkeleton {
    pub parent_instance: gio::GDBusInterfaceSkeleton,
    pub priv_: *mut UDisksVolumeGroupSkeletonPrivate,
}

impl ::std::fmt::Debug for UDisksVolumeGroupSkeleton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UDisksVolumeGroupSkeleton @ {self:p}"))
         .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct UDisksBlock {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksBlock @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksBlockLVM2 {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksBlockLVM2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksBlockLVM2 @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksDrive {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksDrive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksDrive @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksDriveAta {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksDriveAta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksDriveAta @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksEncrypted {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksEncrypted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksEncrypted @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksFilesystem {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksFilesystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksFilesystem @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksFilesystemBTRFS {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksFilesystemBTRFS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksFilesystemBTRFS @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksJob {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksJob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksJob @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksLogicalVolume {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksLogicalVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksLogicalVolume @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksLoop {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksLoop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksLoop @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksMDRaid {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksMDRaid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksMDRaid @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksManager {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksManager @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksManagerBTRFS {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksManagerBTRFS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksManagerBTRFS @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksManagerLVM2 {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksManagerLVM2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksManagerLVM2 @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksObject {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksObject @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksPartition {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksPartition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksPartition @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksPartitionTable {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksPartitionTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksPartitionTable @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksPhysicalVolume {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksPhysicalVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksPhysicalVolume @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksSwapspace {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksSwapspace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksSwapspace @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksVDOVolume {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksVDOVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksVDOVolume @ {self:p}")
    }
}

#[repr(C)]
pub struct UDisksVolumeGroup {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for UDisksVolumeGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "UDisksVolumeGroup @ {self:p}")
    }
}


#[link(name = "udisks2")]
extern "C" {

    //=========================================================================
    // UDisksError
    //=========================================================================
    pub fn udisks_error_get_type() -> GType;
    pub fn udisks_error_quark() -> glib::GQuark;

    //=========================================================================
    // UDisksPartitionTypeInfoFlags
    //=========================================================================
    pub fn udisks_partition_type_info_flags_get_type() -> GType;

    //=========================================================================
    // UDisksPartitionTypeInfo
    //=========================================================================
    pub fn udisks_partition_type_info_get_type() -> GType;
    pub fn udisks_partition_type_info_free(info: *mut UDisksPartitionTypeInfo);

    //=========================================================================
    // UDisksBlockLVM2Proxy
    //=========================================================================
    pub fn udisks_block_lvm2_proxy_get_type() -> GType;
    pub fn udisks_block_lvm2_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksBlockLVM2Proxy;
    pub fn udisks_block_lvm2_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksBlockLVM2Proxy;
    pub fn udisks_block_lvm2_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksBlockLVM2Proxy;
    pub fn udisks_block_lvm2_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksBlockLVM2Proxy;
    pub fn udisks_block_lvm2_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_lvm2_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksBlockLVM2Skeleton
    //=========================================================================
    pub fn udisks_block_lvm2_skeleton_get_type() -> GType;
    pub fn udisks_block_lvm2_skeleton_new() -> *mut UDisksBlockLVM2Skeleton;

    //=========================================================================
    // UDisksBlockProxy
    //=========================================================================
    pub fn udisks_block_proxy_get_type() -> GType;
    pub fn udisks_block_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksBlockProxy;
    pub fn udisks_block_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksBlockProxy;
    pub fn udisks_block_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksBlockProxy;
    pub fn udisks_block_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksBlockProxy;
    pub fn udisks_block_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksBlockSkeleton
    //=========================================================================
    pub fn udisks_block_skeleton_get_type() -> GType;
    pub fn udisks_block_skeleton_new() -> *mut UDisksBlockSkeleton;

    //=========================================================================
    // UDisksClient
    //=========================================================================
    pub fn udisks_client_get_type() -> GType;
    pub fn udisks_client_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksClient;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_client_new_for_connection_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksClient;
    pub fn udisks_client_new_sync(cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksClient;
    pub fn udisks_client_get_job_description_from_operation(operation: *const c_char) -> *mut c_char;
    pub fn udisks_client_new(cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_client_new_for_connection(connection: *mut gio::GDBusConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_client_get_all_blocks_for_mdraid(client: *mut UDisksClient, raid: *mut UDisksMDRaid) -> *mut glib::GList;
    pub fn udisks_client_get_block_for_dev(client: *mut UDisksClient, block_device_number: u64) -> *mut UDisksBlock;
    pub fn udisks_client_get_block_for_drive(client: *mut UDisksClient, drive: *mut UDisksDrive, get_physical: gboolean) -> *mut UDisksBlock;
    pub fn udisks_client_get_block_for_label(client: *mut UDisksClient, label: *const c_char) -> *mut glib::GList;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_client_get_block_for_mdraid(client: *mut UDisksClient, raid: *mut UDisksMDRaid) -> *mut UDisksBlock;
    pub fn udisks_client_get_block_for_uuid(client: *mut UDisksClient, uuid: *const c_char) -> *mut glib::GList;
    pub fn udisks_client_get_cleartext_block(client: *mut UDisksClient, block: *mut UDisksBlock) -> *mut UDisksBlock;
    pub fn udisks_client_get_drive_for_block(client: *mut UDisksClient, block: *mut UDisksBlock) -> *mut UDisksDrive;
    pub fn udisks_client_get_drive_info(client: *mut UDisksClient, drive: *mut UDisksDrive, out_name: *mut *mut c_char, out_description: *mut *mut c_char, out_drive_icon: *mut *mut gio::GIcon, out_media_description: *mut *mut c_char, out_media_icon: *mut *mut gio::GIcon);
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_client_get_drive_siblings(client: *mut UDisksClient, drive: *mut UDisksDrive) -> *mut glib::GList;
    pub fn udisks_client_get_id_for_display(client: *mut UDisksClient, usage: *const c_char, type_: *const c_char, version: *const c_char, long_string: gboolean) -> *mut c_char;
    pub fn udisks_client_get_job_description(client: *mut UDisksClient, job: *mut UDisksJob) -> *mut c_char;
    pub fn udisks_client_get_jobs_for_object(client: *mut UDisksClient, object: *mut UDisksObject) -> *mut glib::GList;
    pub fn udisks_client_get_loop_for_block(client: *mut UDisksClient, block: *mut UDisksBlock) -> *mut UDisksLoop;
    pub fn udisks_client_get_manager(client: *mut UDisksClient) -> *mut UDisksManager;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_client_get_mdraid_for_block(client: *mut UDisksClient, block: *mut UDisksBlock) -> *mut UDisksMDRaid;
    pub fn udisks_client_get_media_compat_for_display(client: *mut UDisksClient, media_compat: *const *const c_char) -> *mut c_char;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_client_get_members_for_mdraid(client: *mut UDisksClient, raid: *mut UDisksMDRaid) -> *mut glib::GList;
    pub fn udisks_client_get_object(client: *mut UDisksClient, object_path: *const c_char) -> *mut UDisksObject;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_client_get_object_info(client: *mut UDisksClient, object: *mut UDisksObject) -> *mut UDisksObjectInfo;
    pub fn udisks_client_get_object_manager(client: *mut UDisksClient) -> *mut gio::GDBusObjectManager;
    pub fn udisks_client_get_partition_info(client: *mut UDisksClient, partition: *mut UDisksPartition) -> *mut c_char;
    pub fn udisks_client_get_partition_table(client: *mut UDisksClient, partition: *mut UDisksPartition) -> *mut UDisksPartitionTable;
    pub fn udisks_client_get_partition_table_subtype_for_display(client: *mut UDisksClient, partition_table_type: *const c_char, partition_table_subtype: *const c_char) -> *const c_char;
    pub fn udisks_client_get_partition_table_subtypes(client: *mut UDisksClient, partition_table_type: *const c_char) -> *mut *const c_char;
    pub fn udisks_client_get_partition_table_type_for_display(client: *mut UDisksClient, partition_table_type: *const c_char) -> *const c_char;
    #[cfg(feature = "v2_1_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_1")))]
    pub fn udisks_client_get_partition_type_and_subtype_for_display(client: *mut UDisksClient, partition_table_type: *const c_char, partition_table_subtype: *const c_char, partition_type: *const c_char) -> *const c_char;
    pub fn udisks_client_get_partition_type_for_display(client: *mut UDisksClient, partition_table_type: *const c_char, partition_type: *const c_char) -> *const c_char;
    pub fn udisks_client_get_partition_type_infos(client: *mut UDisksClient, partition_table_type: *const c_char, partition_table_subtype: *const c_char) -> *mut glib::GList;
    pub fn udisks_client_get_partitions(client: *mut UDisksClient, table: *mut UDisksPartitionTable) -> *mut glib::GList;
    pub fn udisks_client_get_size_for_display(client: *mut UDisksClient, size: u64, use_pow2: gboolean, long_string: gboolean) -> *mut c_char;
    pub fn udisks_client_peek_object(client: *mut UDisksClient, object_path: *const c_char) -> *mut UDisksObject;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_client_queue_changed(client: *mut UDisksClient);
    pub fn udisks_client_settle(client: *mut UDisksClient);

    //=========================================================================
    // UDisksDriveAtaProxy
    //=========================================================================
    pub fn udisks_drive_ata_proxy_get_type() -> GType;
    pub fn udisks_drive_ata_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksDriveAtaProxy;
    pub fn udisks_drive_ata_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksDriveAtaProxy;
    pub fn udisks_drive_ata_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksDriveAtaProxy;
    pub fn udisks_drive_ata_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksDriveAtaProxy;
    pub fn udisks_drive_ata_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksDriveAtaSkeleton
    //=========================================================================
    pub fn udisks_drive_ata_skeleton_get_type() -> GType;
    pub fn udisks_drive_ata_skeleton_new() -> *mut UDisksDriveAtaSkeleton;

    //=========================================================================
    // UDisksDriveProxy
    //=========================================================================
    pub fn udisks_drive_proxy_get_type() -> GType;
    pub fn udisks_drive_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksDriveProxy;
    pub fn udisks_drive_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksDriveProxy;
    pub fn udisks_drive_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksDriveProxy;
    pub fn udisks_drive_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksDriveProxy;
    pub fn udisks_drive_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksDriveSkeleton
    //=========================================================================
    pub fn udisks_drive_skeleton_get_type() -> GType;
    pub fn udisks_drive_skeleton_new() -> *mut UDisksDriveSkeleton;

    //=========================================================================
    // UDisksEncryptedProxy
    //=========================================================================
    pub fn udisks_encrypted_proxy_get_type() -> GType;
    pub fn udisks_encrypted_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksEncryptedProxy;
    pub fn udisks_encrypted_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksEncryptedProxy;
    pub fn udisks_encrypted_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksEncryptedProxy;
    pub fn udisks_encrypted_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksEncryptedProxy;
    pub fn udisks_encrypted_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_encrypted_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksEncryptedSkeleton
    //=========================================================================
    pub fn udisks_encrypted_skeleton_get_type() -> GType;
    pub fn udisks_encrypted_skeleton_new() -> *mut UDisksEncryptedSkeleton;

    //=========================================================================
    // UDisksFilesystemBTRFSProxy
    //=========================================================================
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_proxy_get_type() -> GType;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksFilesystemBTRFSProxy;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksFilesystemBTRFSProxy;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksFilesystemBTRFSProxy;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksFilesystemBTRFSProxy;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksFilesystemBTRFSSkeleton
    //=========================================================================
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_skeleton_get_type() -> GType;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_skeleton_new() -> *mut UDisksFilesystemBTRFSSkeleton;

    //=========================================================================
    // UDisksFilesystemProxy
    //=========================================================================
    pub fn udisks_filesystem_proxy_get_type() -> GType;
    pub fn udisks_filesystem_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksFilesystemProxy;
    pub fn udisks_filesystem_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksFilesystemProxy;
    pub fn udisks_filesystem_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksFilesystemProxy;
    pub fn udisks_filesystem_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksFilesystemProxy;
    pub fn udisks_filesystem_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_filesystem_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksFilesystemSkeleton
    //=========================================================================
    pub fn udisks_filesystem_skeleton_get_type() -> GType;
    pub fn udisks_filesystem_skeleton_new() -> *mut UDisksFilesystemSkeleton;

    //=========================================================================
    // UDisksJobProxy
    //=========================================================================
    pub fn udisks_job_proxy_get_type() -> GType;
    pub fn udisks_job_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksJobProxy;
    pub fn udisks_job_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksJobProxy;
    pub fn udisks_job_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksJobProxy;
    pub fn udisks_job_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksJobProxy;
    pub fn udisks_job_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_job_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksJobSkeleton
    //=========================================================================
    pub fn udisks_job_skeleton_get_type() -> GType;
    pub fn udisks_job_skeleton_new() -> *mut UDisksJobSkeleton;

    //=========================================================================
    // UDisksLogicalVolumeProxy
    //=========================================================================
    pub fn udisks_logical_volume_proxy_get_type() -> GType;
    pub fn udisks_logical_volume_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksLogicalVolumeProxy;
    pub fn udisks_logical_volume_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksLogicalVolumeProxy;
    pub fn udisks_logical_volume_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksLogicalVolumeProxy;
    pub fn udisks_logical_volume_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksLogicalVolumeProxy;
    pub fn udisks_logical_volume_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_logical_volume_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksLogicalVolumeSkeleton
    //=========================================================================
    pub fn udisks_logical_volume_skeleton_get_type() -> GType;
    pub fn udisks_logical_volume_skeleton_new() -> *mut UDisksLogicalVolumeSkeleton;

    //=========================================================================
    // UDisksLoopProxy
    //=========================================================================
    pub fn udisks_loop_proxy_get_type() -> GType;
    pub fn udisks_loop_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksLoopProxy;
    pub fn udisks_loop_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksLoopProxy;
    pub fn udisks_loop_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksLoopProxy;
    pub fn udisks_loop_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksLoopProxy;
    pub fn udisks_loop_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_loop_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksLoopSkeleton
    //=========================================================================
    pub fn udisks_loop_skeleton_get_type() -> GType;
    pub fn udisks_loop_skeleton_new() -> *mut UDisksLoopSkeleton;

    //=========================================================================
    // UDisksMDRaidProxy
    //=========================================================================
    pub fn udisks_mdraid_proxy_get_type() -> GType;
    pub fn udisks_mdraid_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksMDRaidProxy;
    pub fn udisks_mdraid_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksMDRaidProxy;
    pub fn udisks_mdraid_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksMDRaidProxy;
    pub fn udisks_mdraid_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksMDRaidProxy;
    pub fn udisks_mdraid_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_mdraid_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksMDRaidSkeleton
    //=========================================================================
    pub fn udisks_mdraid_skeleton_get_type() -> GType;
    pub fn udisks_mdraid_skeleton_new() -> *mut UDisksMDRaidSkeleton;

    //=========================================================================
    // UDisksManagerBTRFSProxy
    //=========================================================================
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_proxy_get_type() -> GType;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksManagerBTRFSProxy;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksManagerBTRFSProxy;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksManagerBTRFSProxy;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksManagerBTRFSProxy;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksManagerBTRFSSkeleton
    //=========================================================================
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_skeleton_get_type() -> GType;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_skeleton_new() -> *mut UDisksManagerBTRFSSkeleton;

    //=========================================================================
    // UDisksManagerLVM2Proxy
    //=========================================================================
    pub fn udisks_manager_lvm2_proxy_get_type() -> GType;
    pub fn udisks_manager_lvm2_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksManagerLVM2Proxy;
    pub fn udisks_manager_lvm2_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksManagerLVM2Proxy;
    pub fn udisks_manager_lvm2_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksManagerLVM2Proxy;
    pub fn udisks_manager_lvm2_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksManagerLVM2Proxy;
    pub fn udisks_manager_lvm2_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_manager_lvm2_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksManagerLVM2Skeleton
    //=========================================================================
    pub fn udisks_manager_lvm2_skeleton_get_type() -> GType;
    pub fn udisks_manager_lvm2_skeleton_new() -> *mut UDisksManagerLVM2Skeleton;

    //=========================================================================
    // UDisksManagerProxy
    //=========================================================================
    pub fn udisks_manager_proxy_get_type() -> GType;
    pub fn udisks_manager_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksManagerProxy;
    pub fn udisks_manager_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksManagerProxy;
    pub fn udisks_manager_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksManagerProxy;
    pub fn udisks_manager_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksManagerProxy;
    pub fn udisks_manager_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_manager_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksManagerSkeleton
    //=========================================================================
    pub fn udisks_manager_skeleton_get_type() -> GType;
    pub fn udisks_manager_skeleton_new() -> *mut UDisksManagerSkeleton;

    //=========================================================================
    // UDisksObjectInfo
    //=========================================================================
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_type() -> GType;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_description(info: *mut UDisksObjectInfo) -> *const c_char;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_icon(info: *mut UDisksObjectInfo) -> *mut gio::GIcon;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_icon_symbolic(info: *mut UDisksObjectInfo) -> *mut gio::GIcon;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_media_description(info: *mut UDisksObjectInfo) -> *const c_char;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_media_icon(info: *mut UDisksObjectInfo) -> *mut gio::GIcon;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_media_icon_symbolic(info: *mut UDisksObjectInfo) -> *mut gio::GIcon;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_name(info: *mut UDisksObjectInfo) -> *const c_char;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_object(info: *mut UDisksObjectInfo) -> *mut UDisksObject;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_one_liner(info: *mut UDisksObjectInfo) -> *const c_char;
    #[cfg(feature = "v2_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1")))]
    pub fn udisks_object_info_get_sort_key(info: *mut UDisksObjectInfo) -> *const c_char;

    //=========================================================================
    // UDisksObjectManagerClient
    //=========================================================================
    pub fn udisks_object_manager_client_get_type() -> GType;
    pub fn udisks_object_manager_client_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksObjectManagerClient;
    pub fn udisks_object_manager_client_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksObjectManagerClient;
    pub fn udisks_object_manager_client_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusObjectManagerClientFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksObjectManagerClient;
    pub fn udisks_object_manager_client_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusObjectManagerClientFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksObjectManagerClient;
    pub fn udisks_object_manager_client_get_proxy_type(manager: *mut gio::GDBusObjectManagerClient, object_path: *const c_char, interface_name: *const c_char, user_data: gpointer) -> GType;
    pub fn udisks_object_manager_client_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusObjectManagerClientFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_object_manager_client_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusObjectManagerClientFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksObjectProxy
    //=========================================================================
    pub fn udisks_object_proxy_get_type() -> GType;
    pub fn udisks_object_proxy_new(connection: *mut gio::GDBusConnection, object_path: *const c_char) -> *mut UDisksObjectProxy;

    //=========================================================================
    // UDisksObjectSkeleton
    //=========================================================================
    pub fn udisks_object_skeleton_get_type() -> GType;
    pub fn udisks_object_skeleton_new(object_path: *const c_char) -> *mut UDisksObjectSkeleton;
    pub fn udisks_object_skeleton_set_block(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksBlock);
    pub fn udisks_object_skeleton_set_block_lvm2(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksBlockLVM2);
    pub fn udisks_object_skeleton_set_drive(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksDrive);
    pub fn udisks_object_skeleton_set_drive_ata(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksDriveAta);
    pub fn udisks_object_skeleton_set_encrypted(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksEncrypted);
    pub fn udisks_object_skeleton_set_filesystem(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksFilesystem);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_object_skeleton_set_filesystem_btrfs(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksFilesystemBTRFS);
    pub fn udisks_object_skeleton_set_job(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksJob);
    pub fn udisks_object_skeleton_set_logical_volume(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksLogicalVolume);
    pub fn udisks_object_skeleton_set_loop(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksLoop);
    pub fn udisks_object_skeleton_set_manager(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksManager);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_object_skeleton_set_manager_btrfs(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksManagerBTRFS);
    pub fn udisks_object_skeleton_set_manager_lvm2(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksManagerLVM2);
    pub fn udisks_object_skeleton_set_mdraid(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksMDRaid);
    pub fn udisks_object_skeleton_set_partition(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksPartition);
    pub fn udisks_object_skeleton_set_partition_table(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksPartitionTable);
    pub fn udisks_object_skeleton_set_physical_volume(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksPhysicalVolume);
    pub fn udisks_object_skeleton_set_swapspace(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksSwapspace);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_object_skeleton_set_vdo_volume(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksVDOVolume);
    pub fn udisks_object_skeleton_set_volume_group(object: *mut UDisksObjectSkeleton, interface_: *mut UDisksVolumeGroup);

    //=========================================================================
    // UDisksPartitionProxy
    //=========================================================================
    pub fn udisks_partition_proxy_get_type() -> GType;
    pub fn udisks_partition_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksPartitionProxy;
    pub fn udisks_partition_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksPartitionProxy;
    pub fn udisks_partition_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksPartitionProxy;
    pub fn udisks_partition_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksPartitionProxy;
    pub fn udisks_partition_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksPartitionSkeleton
    //=========================================================================
    pub fn udisks_partition_skeleton_get_type() -> GType;
    pub fn udisks_partition_skeleton_new() -> *mut UDisksPartitionSkeleton;

    //=========================================================================
    // UDisksPartitionTableProxy
    //=========================================================================
    pub fn udisks_partition_table_proxy_get_type() -> GType;
    pub fn udisks_partition_table_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksPartitionTableProxy;
    pub fn udisks_partition_table_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksPartitionTableProxy;
    pub fn udisks_partition_table_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksPartitionTableProxy;
    pub fn udisks_partition_table_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksPartitionTableProxy;
    pub fn udisks_partition_table_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_table_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksPartitionTableSkeleton
    //=========================================================================
    pub fn udisks_partition_table_skeleton_get_type() -> GType;
    pub fn udisks_partition_table_skeleton_new() -> *mut UDisksPartitionTableSkeleton;

    //=========================================================================
    // UDisksPhysicalVolumeProxy
    //=========================================================================
    pub fn udisks_physical_volume_proxy_get_type() -> GType;
    pub fn udisks_physical_volume_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksPhysicalVolumeProxy;
    pub fn udisks_physical_volume_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksPhysicalVolumeProxy;
    pub fn udisks_physical_volume_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksPhysicalVolumeProxy;
    pub fn udisks_physical_volume_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksPhysicalVolumeProxy;
    pub fn udisks_physical_volume_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_physical_volume_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksPhysicalVolumeSkeleton
    //=========================================================================
    pub fn udisks_physical_volume_skeleton_get_type() -> GType;
    pub fn udisks_physical_volume_skeleton_new() -> *mut UDisksPhysicalVolumeSkeleton;

    //=========================================================================
    // UDisksSwapspaceProxy
    //=========================================================================
    pub fn udisks_swapspace_proxy_get_type() -> GType;
    pub fn udisks_swapspace_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksSwapspaceProxy;
    pub fn udisks_swapspace_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksSwapspaceProxy;
    pub fn udisks_swapspace_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksSwapspaceProxy;
    pub fn udisks_swapspace_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksSwapspaceProxy;
    pub fn udisks_swapspace_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_swapspace_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksSwapspaceSkeleton
    //=========================================================================
    pub fn udisks_swapspace_skeleton_get_type() -> GType;
    pub fn udisks_swapspace_skeleton_new() -> *mut UDisksSwapspaceSkeleton;

    //=========================================================================
    // UDisksVDOVolumeProxy
    //=========================================================================
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_proxy_get_type() -> GType;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksVDOVolumeProxy;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksVDOVolumeProxy;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksVDOVolumeProxy;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksVDOVolumeProxy;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksVDOVolumeSkeleton
    //=========================================================================
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_skeleton_get_type() -> GType;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_skeleton_new() -> *mut UDisksVDOVolumeSkeleton;

    //=========================================================================
    // UDisksVolumeGroupProxy
    //=========================================================================
    pub fn udisks_volume_group_proxy_get_type() -> GType;
    pub fn udisks_volume_group_proxy_new_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksVolumeGroupProxy;
    pub fn udisks_volume_group_proxy_new_for_bus_finish(res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut UDisksVolumeGroupProxy;
    pub fn udisks_volume_group_proxy_new_for_bus_sync(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksVolumeGroupProxy;
    pub fn udisks_volume_group_proxy_new_sync(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut UDisksVolumeGroupProxy;
    pub fn udisks_volume_group_proxy_new(connection: *mut gio::GDBusConnection, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_proxy_new_for_bus(bus_type: gio::GBusType, flags: gio::GDBusProxyFlags, name: *const c_char, object_path: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // UDisksVolumeGroupSkeleton
    //=========================================================================
    pub fn udisks_volume_group_skeleton_get_type() -> GType;
    pub fn udisks_volume_group_skeleton_new() -> *mut UDisksVolumeGroupSkeleton;

    //=========================================================================
    // UDisksBlock
    //=========================================================================
    pub fn udisks_block_get_type() -> GType;
    pub fn udisks_block_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_block_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_block_call_add_configuration_item(proxy: *mut UDisksBlock, arg_item: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_add_configuration_item_finish(proxy: *mut UDisksBlock, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_add_configuration_item_sync(proxy: *mut UDisksBlock, arg_item: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_format(proxy: *mut UDisksBlock, arg_type: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_format_finish(proxy: *mut UDisksBlock, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_format_sync(proxy: *mut UDisksBlock, arg_type: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_get_secret_configuration(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_get_secret_configuration_finish(proxy: *mut UDisksBlock, out_configuration: *mut *mut glib::GVariant, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_get_secret_configuration_sync(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, out_configuration: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    pub fn udisks_block_call_open_device(proxy: *mut UDisksBlock, arg_mode: *const c_char, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    pub fn udisks_block_call_open_device_finish(proxy: *mut UDisksBlock, out_fd: *mut *mut glib::GVariant, out_fd_list: *mut *mut gio::GUnixFDList, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    pub fn udisks_block_call_open_device_sync(proxy: *mut UDisksBlock, arg_mode: *const c_char, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, out_fd: *mut *mut glib::GVariant, out_fd_list: *mut *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_open_for_backup(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_open_for_backup_finish(proxy: *mut UDisksBlock, out_fd: *mut *mut glib::GVariant, out_fd_list: *mut *mut gio::GUnixFDList, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_open_for_backup_sync(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, out_fd: *mut *mut glib::GVariant, out_fd_list: *mut *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_open_for_benchmark(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_open_for_benchmark_finish(proxy: *mut UDisksBlock, out_fd: *mut *mut glib::GVariant, out_fd_list: *mut *mut gio::GUnixFDList, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_open_for_benchmark_sync(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, out_fd: *mut *mut glib::GVariant, out_fd_list: *mut *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_open_for_restore(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_open_for_restore_finish(proxy: *mut UDisksBlock, out_fd: *mut *mut glib::GVariant, out_fd_list: *mut *mut gio::GUnixFDList, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_open_for_restore_sync(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, out_fd: *mut *mut glib::GVariant, out_fd_list: *mut *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_remove_configuration_item(proxy: *mut UDisksBlock, arg_item: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_remove_configuration_item_finish(proxy: *mut UDisksBlock, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_remove_configuration_item_sync(proxy: *mut UDisksBlock, arg_item: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_rescan(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_rescan_finish(proxy: *mut UDisksBlock, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_rescan_sync(proxy: *mut UDisksBlock, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_update_configuration_item(proxy: *mut UDisksBlock, arg_old_item: *mut glib::GVariant, arg_new_item: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_block_call_update_configuration_item_finish(proxy: *mut UDisksBlock, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_call_update_configuration_item_sync(proxy: *mut UDisksBlock, arg_old_item: *mut glib::GVariant, arg_new_item: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_block_complete_add_configuration_item(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_block_complete_format(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_block_complete_get_secret_configuration(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation, configuration: *mut glib::GVariant);
    #[cfg(feature = "v2_7_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    pub fn udisks_block_complete_open_device(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation, fd_list: *mut gio::GUnixFDList, fd: *mut glib::GVariant);
    pub fn udisks_block_complete_open_for_backup(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation, fd_list: *mut gio::GUnixFDList, fd: *mut glib::GVariant);
    pub fn udisks_block_complete_open_for_benchmark(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation, fd_list: *mut gio::GUnixFDList, fd: *mut glib::GVariant);
    pub fn udisks_block_complete_open_for_restore(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation, fd_list: *mut gio::GUnixFDList, fd: *mut glib::GVariant);
    pub fn udisks_block_complete_remove_configuration_item(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_block_complete_rescan(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_block_complete_update_configuration_item(object: *mut UDisksBlock, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_block_dup_configuration(object: *mut UDisksBlock) -> *mut glib::GVariant;
    pub fn udisks_block_dup_crypto_backing_device(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_device(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_drive(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_hint_icon_name(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_hint_name(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_hint_symbolic_icon_name(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_id(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_id_label(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_id_type(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_id_usage(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_id_uuid(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_id_version(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_mdraid(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_mdraid_member(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_preferred_device(object: *mut UDisksBlock) -> *mut c_char;
    pub fn udisks_block_dup_symlinks(object: *mut UDisksBlock) -> *mut *mut c_char;
    pub fn udisks_block_dup_userspace_mount_options(object: *mut UDisksBlock) -> *mut *mut c_char;
    pub fn udisks_block_get_configuration(object: *mut UDisksBlock) -> *mut glib::GVariant;
    pub fn udisks_block_get_crypto_backing_device(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_device(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_device_number(object: *mut UDisksBlock) -> u64;
    pub fn udisks_block_get_drive(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_hint_auto(object: *mut UDisksBlock) -> gboolean;
    pub fn udisks_block_get_hint_icon_name(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_hint_ignore(object: *mut UDisksBlock) -> gboolean;
    pub fn udisks_block_get_hint_name(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_hint_partitionable(object: *mut UDisksBlock) -> gboolean;
    pub fn udisks_block_get_hint_symbolic_icon_name(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_hint_system(object: *mut UDisksBlock) -> gboolean;
    pub fn udisks_block_get_id(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_id_label(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_id_type(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_id_usage(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_id_uuid(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_id_version(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_mdraid(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_mdraid_member(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_preferred_device(object: *mut UDisksBlock) -> *const c_char;
    pub fn udisks_block_get_read_only(object: *mut UDisksBlock) -> gboolean;
    pub fn udisks_block_get_size(object: *mut UDisksBlock) -> u64;
    pub fn udisks_block_get_symlinks(object: *mut UDisksBlock) -> *const *const c_char;
    pub fn udisks_block_get_userspace_mount_options(object: *mut UDisksBlock) -> *const *const c_char;
    pub fn udisks_block_set_configuration(object: *mut UDisksBlock, value: *mut glib::GVariant);
    pub fn udisks_block_set_crypto_backing_device(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_device(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_device_number(object: *mut UDisksBlock, value: u64);
    pub fn udisks_block_set_drive(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_hint_auto(object: *mut UDisksBlock, value: gboolean);
    pub fn udisks_block_set_hint_icon_name(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_hint_ignore(object: *mut UDisksBlock, value: gboolean);
    pub fn udisks_block_set_hint_name(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_hint_partitionable(object: *mut UDisksBlock, value: gboolean);
    pub fn udisks_block_set_hint_symbolic_icon_name(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_hint_system(object: *mut UDisksBlock, value: gboolean);
    pub fn udisks_block_set_id(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_id_label(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_id_type(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_id_usage(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_id_uuid(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_id_version(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_mdraid(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_mdraid_member(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_preferred_device(object: *mut UDisksBlock, value: *const c_char);
    pub fn udisks_block_set_read_only(object: *mut UDisksBlock, value: gboolean);
    pub fn udisks_block_set_size(object: *mut UDisksBlock, value: u64);
    pub fn udisks_block_set_symlinks(object: *mut UDisksBlock, value: *const *const c_char);
    pub fn udisks_block_set_userspace_mount_options(object: *mut UDisksBlock, value: *const *const c_char);

    //=========================================================================
    // UDisksBlockLVM2
    //=========================================================================
    pub fn udisks_block_lvm2_get_type() -> GType;
    pub fn udisks_block_lvm2_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_block_lvm2_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_block_lvm2_dup_logical_volume(object: *mut UDisksBlockLVM2) -> *mut c_char;
    pub fn udisks_block_lvm2_get_logical_volume(object: *mut UDisksBlockLVM2) -> *const c_char;
    pub fn udisks_block_lvm2_set_logical_volume(object: *mut UDisksBlockLVM2, value: *const c_char);

    //=========================================================================
    // UDisksDrive
    //=========================================================================
    pub fn udisks_drive_get_type() -> GType;
    pub fn udisks_drive_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_drive_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_drive_call_eject(proxy: *mut UDisksDrive, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_call_eject_finish(proxy: *mut UDisksDrive, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_call_eject_sync(proxy: *mut UDisksDrive, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_call_power_off(proxy: *mut UDisksDrive, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_call_power_off_finish(proxy: *mut UDisksDrive, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_call_power_off_sync(proxy: *mut UDisksDrive, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_call_set_configuration(proxy: *mut UDisksDrive, arg_value: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_call_set_configuration_finish(proxy: *mut UDisksDrive, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_call_set_configuration_sync(proxy: *mut UDisksDrive, arg_value: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_complete_eject(object: *mut UDisksDrive, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_complete_power_off(object: *mut UDisksDrive, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_complete_set_configuration(object: *mut UDisksDrive, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_dup_configuration(object: *mut UDisksDrive) -> *mut glib::GVariant;
    pub fn udisks_drive_dup_connection_bus(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_id(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_media(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_media_compatibility(object: *mut UDisksDrive) -> *mut *mut c_char;
    pub fn udisks_drive_dup_model(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_revision(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_seat(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_serial(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_sibling_id(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_sort_key(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_vendor(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_dup_wwn(object: *mut UDisksDrive) -> *mut c_char;
    pub fn udisks_drive_get_can_power_off(object: *mut UDisksDrive) -> gboolean;
    pub fn udisks_drive_get_configuration(object: *mut UDisksDrive) -> *mut glib::GVariant;
    pub fn udisks_drive_get_connection_bus(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_ejectable(object: *mut UDisksDrive) -> gboolean;
    pub fn udisks_drive_get_id(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_media(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_media_available(object: *mut UDisksDrive) -> gboolean;
    pub fn udisks_drive_get_media_change_detected(object: *mut UDisksDrive) -> gboolean;
    pub fn udisks_drive_get_media_compatibility(object: *mut UDisksDrive) -> *const *const c_char;
    pub fn udisks_drive_get_media_removable(object: *mut UDisksDrive) -> gboolean;
    pub fn udisks_drive_get_model(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_optical(object: *mut UDisksDrive) -> gboolean;
    pub fn udisks_drive_get_optical_blank(object: *mut UDisksDrive) -> gboolean;
    pub fn udisks_drive_get_optical_num_audio_tracks(object: *mut UDisksDrive) -> c_uint;
    pub fn udisks_drive_get_optical_num_data_tracks(object: *mut UDisksDrive) -> c_uint;
    pub fn udisks_drive_get_optical_num_sessions(object: *mut UDisksDrive) -> c_uint;
    pub fn udisks_drive_get_optical_num_tracks(object: *mut UDisksDrive) -> c_uint;
    pub fn udisks_drive_get_removable(object: *mut UDisksDrive) -> gboolean;
    pub fn udisks_drive_get_revision(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_rotation_rate(object: *mut UDisksDrive) -> c_int;
    pub fn udisks_drive_get_seat(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_serial(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_sibling_id(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_size(object: *mut UDisksDrive) -> u64;
    pub fn udisks_drive_get_sort_key(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_time_detected(object: *mut UDisksDrive) -> u64;
    pub fn udisks_drive_get_time_media_detected(object: *mut UDisksDrive) -> u64;
    pub fn udisks_drive_get_vendor(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_get_wwn(object: *mut UDisksDrive) -> *const c_char;
    pub fn udisks_drive_set_can_power_off(object: *mut UDisksDrive, value: gboolean);
    pub fn udisks_drive_set_configuration(object: *mut UDisksDrive, value: *mut glib::GVariant);
    pub fn udisks_drive_set_connection_bus(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_ejectable(object: *mut UDisksDrive, value: gboolean);
    pub fn udisks_drive_set_id(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_media(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_media_available(object: *mut UDisksDrive, value: gboolean);
    pub fn udisks_drive_set_media_change_detected(object: *mut UDisksDrive, value: gboolean);
    pub fn udisks_drive_set_media_compatibility(object: *mut UDisksDrive, value: *const *const c_char);
    pub fn udisks_drive_set_media_removable(object: *mut UDisksDrive, value: gboolean);
    pub fn udisks_drive_set_model(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_optical(object: *mut UDisksDrive, value: gboolean);
    pub fn udisks_drive_set_optical_blank(object: *mut UDisksDrive, value: gboolean);
    pub fn udisks_drive_set_optical_num_audio_tracks(object: *mut UDisksDrive, value: c_uint);
    pub fn udisks_drive_set_optical_num_data_tracks(object: *mut UDisksDrive, value: c_uint);
    pub fn udisks_drive_set_optical_num_sessions(object: *mut UDisksDrive, value: c_uint);
    pub fn udisks_drive_set_optical_num_tracks(object: *mut UDisksDrive, value: c_uint);
    pub fn udisks_drive_set_removable(object: *mut UDisksDrive, value: gboolean);
    pub fn udisks_drive_set_revision(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_rotation_rate(object: *mut UDisksDrive, value: c_int);
    pub fn udisks_drive_set_seat(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_serial(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_sibling_id(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_size(object: *mut UDisksDrive, value: u64);
    pub fn udisks_drive_set_sort_key(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_time_detected(object: *mut UDisksDrive, value: u64);
    pub fn udisks_drive_set_time_media_detected(object: *mut UDisksDrive, value: u64);
    pub fn udisks_drive_set_vendor(object: *mut UDisksDrive, value: *const c_char);
    pub fn udisks_drive_set_wwn(object: *mut UDisksDrive, value: *const c_char);

    //=========================================================================
    // UDisksDriveAta
    //=========================================================================
    pub fn udisks_drive_ata_get_type() -> GType;
    pub fn udisks_drive_ata_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_drive_ata_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_drive_ata_call_pm_get_state(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_pm_get_state_finish(proxy: *mut UDisksDriveAta, out_state: *mut u8, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_pm_get_state_sync(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, out_state: *mut u8, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_pm_standby(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_pm_standby_finish(proxy: *mut UDisksDriveAta, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_pm_standby_sync(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_pm_wakeup(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_pm_wakeup_finish(proxy: *mut UDisksDriveAta, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_pm_wakeup_sync(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_security_erase_unit(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_security_erase_unit_finish(proxy: *mut UDisksDriveAta, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_security_erase_unit_sync(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_get_attributes(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_smart_get_attributes_finish(proxy: *mut UDisksDriveAta, out_attributes: *mut *mut glib::GVariant, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_get_attributes_sync(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, out_attributes: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_selftest_abort(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_smart_selftest_abort_finish(proxy: *mut UDisksDriveAta, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_selftest_abort_sync(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_selftest_start(proxy: *mut UDisksDriveAta, arg_type: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_smart_selftest_start_finish(proxy: *mut UDisksDriveAta, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_selftest_start_sync(proxy: *mut UDisksDriveAta, arg_type: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_set_enabled(proxy: *mut UDisksDriveAta, arg_value: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_smart_set_enabled_finish(proxy: *mut UDisksDriveAta, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_set_enabled_sync(proxy: *mut UDisksDriveAta, arg_value: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_update(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_drive_ata_call_smart_update_finish(proxy: *mut UDisksDriveAta, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_call_smart_update_sync(proxy: *mut UDisksDriveAta, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_drive_ata_complete_pm_get_state(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation, state: c_uchar);
    pub fn udisks_drive_ata_complete_pm_standby(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_ata_complete_pm_wakeup(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_ata_complete_security_erase_unit(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_ata_complete_smart_get_attributes(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation, attributes: *mut glib::GVariant);
    pub fn udisks_drive_ata_complete_smart_selftest_abort(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_ata_complete_smart_selftest_start(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_ata_complete_smart_set_enabled(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_ata_complete_smart_update(object: *mut UDisksDriveAta, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_drive_ata_dup_smart_selftest_status(object: *mut UDisksDriveAta) -> *mut c_char;
    pub fn udisks_drive_ata_get_aam_enabled(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_aam_supported(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_aam_vendor_recommended_value(object: *mut UDisksDriveAta) -> c_int;
    pub fn udisks_drive_ata_get_apm_enabled(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_apm_supported(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_pm_enabled(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_pm_supported(object: *mut UDisksDriveAta) -> gboolean;
    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    pub fn udisks_drive_ata_get_read_lookahead_enabled(object: *mut UDisksDriveAta) -> gboolean;
    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    pub fn udisks_drive_ata_get_read_lookahead_supported(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_security_enhanced_erase_unit_minutes(object: *mut UDisksDriveAta) -> c_int;
    pub fn udisks_drive_ata_get_security_erase_unit_minutes(object: *mut UDisksDriveAta) -> c_int;
    pub fn udisks_drive_ata_get_security_frozen(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_smart_enabled(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_smart_failing(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_smart_num_attributes_failed_in_the_past(object: *mut UDisksDriveAta) -> c_int;
    pub fn udisks_drive_ata_get_smart_num_attributes_failing(object: *mut UDisksDriveAta) -> c_int;
    pub fn udisks_drive_ata_get_smart_num_bad_sectors(object: *mut UDisksDriveAta) -> i64;
    pub fn udisks_drive_ata_get_smart_power_on_seconds(object: *mut UDisksDriveAta) -> u64;
    pub fn udisks_drive_ata_get_smart_selftest_percent_remaining(object: *mut UDisksDriveAta) -> c_int;
    pub fn udisks_drive_ata_get_smart_selftest_status(object: *mut UDisksDriveAta) -> *const c_char;
    pub fn udisks_drive_ata_get_smart_supported(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_smart_temperature(object: *mut UDisksDriveAta) -> c_double;
    pub fn udisks_drive_ata_get_smart_updated(object: *mut UDisksDriveAta) -> u64;
    pub fn udisks_drive_ata_get_write_cache_enabled(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_get_write_cache_supported(object: *mut UDisksDriveAta) -> gboolean;
    pub fn udisks_drive_ata_set_aam_enabled(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_aam_supported(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_aam_vendor_recommended_value(object: *mut UDisksDriveAta, value: c_int);
    pub fn udisks_drive_ata_set_apm_enabled(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_apm_supported(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_pm_enabled(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_pm_supported(object: *mut UDisksDriveAta, value: gboolean);
    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    pub fn udisks_drive_ata_set_read_lookahead_enabled(object: *mut UDisksDriveAta, value: gboolean);
    #[cfg(feature = "v2_1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_7")))]
    pub fn udisks_drive_ata_set_read_lookahead_supported(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_security_enhanced_erase_unit_minutes(object: *mut UDisksDriveAta, value: c_int);
    pub fn udisks_drive_ata_set_security_erase_unit_minutes(object: *mut UDisksDriveAta, value: c_int);
    pub fn udisks_drive_ata_set_security_frozen(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_smart_enabled(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_smart_failing(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_smart_num_attributes_failed_in_the_past(object: *mut UDisksDriveAta, value: c_int);
    pub fn udisks_drive_ata_set_smart_num_attributes_failing(object: *mut UDisksDriveAta, value: c_int);
    pub fn udisks_drive_ata_set_smart_num_bad_sectors(object: *mut UDisksDriveAta, value: i64);
    pub fn udisks_drive_ata_set_smart_power_on_seconds(object: *mut UDisksDriveAta, value: u64);
    pub fn udisks_drive_ata_set_smart_selftest_percent_remaining(object: *mut UDisksDriveAta, value: c_int);
    pub fn udisks_drive_ata_set_smart_selftest_status(object: *mut UDisksDriveAta, value: *const c_char);
    pub fn udisks_drive_ata_set_smart_supported(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_smart_temperature(object: *mut UDisksDriveAta, value: c_double);
    pub fn udisks_drive_ata_set_smart_updated(object: *mut UDisksDriveAta, value: u64);
    pub fn udisks_drive_ata_set_write_cache_enabled(object: *mut UDisksDriveAta, value: gboolean);
    pub fn udisks_drive_ata_set_write_cache_supported(object: *mut UDisksDriveAta, value: gboolean);

    //=========================================================================
    // UDisksEncrypted
    //=========================================================================
    pub fn udisks_encrypted_get_type() -> GType;
    pub fn udisks_encrypted_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_encrypted_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_encrypted_call_change_passphrase(proxy: *mut UDisksEncrypted, arg_passphrase: *const c_char, arg_new_passphrase: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_encrypted_call_change_passphrase_finish(proxy: *mut UDisksEncrypted, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_encrypted_call_change_passphrase_sync(proxy: *mut UDisksEncrypted, arg_passphrase: *const c_char, arg_new_passphrase: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_encrypted_call_lock(proxy: *mut UDisksEncrypted, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_encrypted_call_lock_finish(proxy: *mut UDisksEncrypted, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_encrypted_call_lock_sync(proxy: *mut UDisksEncrypted, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_8")))]
    pub fn udisks_encrypted_call_resize(proxy: *mut UDisksEncrypted, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_8")))]
    pub fn udisks_encrypted_call_resize_finish(proxy: *mut UDisksEncrypted, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_8")))]
    pub fn udisks_encrypted_call_resize_sync(proxy: *mut UDisksEncrypted, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_encrypted_call_unlock(proxy: *mut UDisksEncrypted, arg_passphrase: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_encrypted_call_unlock_finish(proxy: *mut UDisksEncrypted, out_cleartext_device: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_encrypted_call_unlock_sync(proxy: *mut UDisksEncrypted, arg_passphrase: *const c_char, arg_options: *mut glib::GVariant, out_cleartext_device: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_encrypted_complete_change_passphrase(object: *mut UDisksEncrypted, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_encrypted_complete_lock(object: *mut UDisksEncrypted, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_8")))]
    pub fn udisks_encrypted_complete_resize(object: *mut UDisksEncrypted, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_encrypted_complete_unlock(object: *mut UDisksEncrypted, invocation: *mut gio::GDBusMethodInvocation, cleartext_device: *const c_char);
    pub fn udisks_encrypted_dup_child_configuration(object: *mut UDisksEncrypted) -> *mut glib::GVariant;
    pub fn udisks_encrypted_dup_cleartext_device(object: *mut UDisksEncrypted) -> *mut c_char;
    pub fn udisks_encrypted_dup_hint_encryption_type(object: *mut UDisksEncrypted) -> *mut c_char;
    pub fn udisks_encrypted_get_child_configuration(object: *mut UDisksEncrypted) -> *mut glib::GVariant;
    pub fn udisks_encrypted_get_cleartext_device(object: *mut UDisksEncrypted) -> *const c_char;
    pub fn udisks_encrypted_get_hint_encryption_type(object: *mut UDisksEncrypted) -> *const c_char;
    pub fn udisks_encrypted_get_metadata_size(object: *mut UDisksEncrypted) -> u64;
    pub fn udisks_encrypted_set_child_configuration(object: *mut UDisksEncrypted, value: *mut glib::GVariant);
    pub fn udisks_encrypted_set_cleartext_device(object: *mut UDisksEncrypted, value: *const c_char);
    pub fn udisks_encrypted_set_hint_encryption_type(object: *mut UDisksEncrypted, value: *const c_char);
    pub fn udisks_encrypted_set_metadata_size(object: *mut UDisksEncrypted, value: u64);

    //=========================================================================
    // UDisksFilesystem
    //=========================================================================
    pub fn udisks_filesystem_get_type() -> GType;
    pub fn udisks_filesystem_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_filesystem_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_check(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_check_finish(proxy: *mut UDisksFilesystem, out_consistent: *mut gboolean, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_check_sync(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, out_consistent: *mut gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_filesystem_call_mount(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_filesystem_call_mount_finish(proxy: *mut UDisksFilesystem, out_mount_path: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_filesystem_call_mount_sync(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, out_mount_path: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_repair(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_repair_finish(proxy: *mut UDisksFilesystem, out_repaired: *mut gboolean, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_repair_sync(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, out_repaired: *mut gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_resize(proxy: *mut UDisksFilesystem, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_resize_finish(proxy: *mut UDisksFilesystem, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_resize_sync(proxy: *mut UDisksFilesystem, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_filesystem_call_set_label(proxy: *mut UDisksFilesystem, arg_label: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_filesystem_call_set_label_finish(proxy: *mut UDisksFilesystem, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_filesystem_call_set_label_sync(proxy: *mut UDisksFilesystem, arg_label: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_take_ownership(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_take_ownership_finish(proxy: *mut UDisksFilesystem, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_call_take_ownership_sync(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_filesystem_call_unmount(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_filesystem_call_unmount_finish(proxy: *mut UDisksFilesystem, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_filesystem_call_unmount_sync(proxy: *mut UDisksFilesystem, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_complete_check(object: *mut UDisksFilesystem, invocation: *mut gio::GDBusMethodInvocation, consistent: gboolean);
    pub fn udisks_filesystem_complete_mount(object: *mut UDisksFilesystem, invocation: *mut gio::GDBusMethodInvocation, mount_path: *const c_char);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_complete_repair(object: *mut UDisksFilesystem, invocation: *mut gio::GDBusMethodInvocation, repaired: gboolean);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_complete_resize(object: *mut UDisksFilesystem, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_filesystem_complete_set_label(object: *mut UDisksFilesystem, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_filesystem_complete_take_ownership(object: *mut UDisksFilesystem, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_filesystem_complete_unmount(object: *mut UDisksFilesystem, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_filesystem_dup_mount_points(object: *mut UDisksFilesystem) -> *mut *mut c_char;
    pub fn udisks_filesystem_get_mount_points(object: *mut UDisksFilesystem) -> *const *const c_char;
    pub fn udisks_filesystem_get_size(object: *mut UDisksFilesystem) -> u64;
    pub fn udisks_filesystem_set_mount_points(object: *mut UDisksFilesystem, value: *const *const c_char);
    pub fn udisks_filesystem_set_size(object: *mut UDisksFilesystem, value: u64);

    //=========================================================================
    // UDisksFilesystemBTRFS
    //=========================================================================
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_get_type() -> GType;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_interface_info() -> *mut gio::GDBusInterfaceInfo;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_add_device(proxy: *mut UDisksFilesystemBTRFS, arg_device: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_add_device_finish(proxy: *mut UDisksFilesystemBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_add_device_sync(proxy: *mut UDisksFilesystemBTRFS, arg_device: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_create_snapshot(proxy: *mut UDisksFilesystemBTRFS, arg_source: *const c_char, arg_dest: *const c_char, arg_ro: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_create_snapshot_finish(proxy: *mut UDisksFilesystemBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_create_snapshot_sync(proxy: *mut UDisksFilesystemBTRFS, arg_source: *const c_char, arg_dest: *const c_char, arg_ro: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_create_subvolume(proxy: *mut UDisksFilesystemBTRFS, arg_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_create_subvolume_finish(proxy: *mut UDisksFilesystemBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_create_subvolume_sync(proxy: *mut UDisksFilesystemBTRFS, arg_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_get_subvolumes(proxy: *mut UDisksFilesystemBTRFS, arg_snapshots_only: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_get_subvolumes_finish(proxy: *mut UDisksFilesystemBTRFS, out_subvolumes: *mut *mut glib::GVariant, out_subvolumes_cnt: *mut c_int, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_get_subvolumes_sync(proxy: *mut UDisksFilesystemBTRFS, arg_snapshots_only: gboolean, arg_options: *mut glib::GVariant, out_subvolumes: *mut *mut glib::GVariant, out_subvolumes_cnt: *mut c_int, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_remove_device(proxy: *mut UDisksFilesystemBTRFS, arg_device: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_remove_device_finish(proxy: *mut UDisksFilesystemBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_remove_device_sync(proxy: *mut UDisksFilesystemBTRFS, arg_device: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_remove_subvolume(proxy: *mut UDisksFilesystemBTRFS, arg_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_remove_subvolume_finish(proxy: *mut UDisksFilesystemBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_remove_subvolume_sync(proxy: *mut UDisksFilesystemBTRFS, arg_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_repair(proxy: *mut UDisksFilesystemBTRFS, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_repair_finish(proxy: *mut UDisksFilesystemBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_repair_sync(proxy: *mut UDisksFilesystemBTRFS, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_resize(proxy: *mut UDisksFilesystemBTRFS, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_resize_finish(proxy: *mut UDisksFilesystemBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_call_resize_sync(proxy: *mut UDisksFilesystemBTRFS, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_set_label(proxy: *mut UDisksFilesystemBTRFS, arg_label: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_set_label_finish(proxy: *mut UDisksFilesystemBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_call_set_label_sync(proxy: *mut UDisksFilesystemBTRFS, arg_label: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_complete_add_device(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_complete_create_snapshot(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_complete_create_subvolume(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_complete_get_subvolumes(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation, subvolumes: *mut glib::GVariant, subvolumes_cnt: c_int);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_complete_remove_device(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_complete_remove_subvolume(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_complete_repair(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_filesystem_btrfs_complete_resize(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_complete_set_label(object: *mut UDisksFilesystemBTRFS, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_dup_label(object: *mut UDisksFilesystemBTRFS) -> *mut c_char;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_dup_uuid(object: *mut UDisksFilesystemBTRFS) -> *mut c_char;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_get_label(object: *mut UDisksFilesystemBTRFS) -> *const c_char;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_get_num_devices(object: *mut UDisksFilesystemBTRFS) -> u64;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_get_used(object: *mut UDisksFilesystemBTRFS) -> u64;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_get_uuid(object: *mut UDisksFilesystemBTRFS) -> *const c_char;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_set_label(object: *mut UDisksFilesystemBTRFS, value: *const c_char);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_set_num_devices(object: *mut UDisksFilesystemBTRFS, value: u64);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_set_used(object: *mut UDisksFilesystemBTRFS, value: u64);
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_filesystem_btrfs_set_uuid(object: *mut UDisksFilesystemBTRFS, value: *const c_char);

    //=========================================================================
    // UDisksJob
    //=========================================================================
    pub fn udisks_job_get_type() -> GType;
    pub fn udisks_job_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_job_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_job_call_cancel(proxy: *mut UDisksJob, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_job_call_cancel_finish(proxy: *mut UDisksJob, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_job_call_cancel_sync(proxy: *mut UDisksJob, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_job_complete_cancel(object: *mut UDisksJob, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_job_dup_objects(object: *mut UDisksJob) -> *mut *mut c_char;
    pub fn udisks_job_dup_operation(object: *mut UDisksJob) -> *mut c_char;
    pub fn udisks_job_emit_completed(object: *mut UDisksJob, arg_success: gboolean, arg_message: *const c_char);
    pub fn udisks_job_get_bytes(object: *mut UDisksJob) -> u64;
    pub fn udisks_job_get_cancelable(object: *mut UDisksJob) -> gboolean;
    pub fn udisks_job_get_expected_end_time(object: *mut UDisksJob) -> u64;
    pub fn udisks_job_get_objects(object: *mut UDisksJob) -> *const *const c_char;
    pub fn udisks_job_get_operation(object: *mut UDisksJob) -> *const c_char;
    pub fn udisks_job_get_progress(object: *mut UDisksJob) -> c_double;
    pub fn udisks_job_get_progress_valid(object: *mut UDisksJob) -> gboolean;
    pub fn udisks_job_get_rate(object: *mut UDisksJob) -> u64;
    pub fn udisks_job_get_start_time(object: *mut UDisksJob) -> u64;
    pub fn udisks_job_get_started_by_uid(object: *mut UDisksJob) -> c_uint;
    pub fn udisks_job_set_bytes(object: *mut UDisksJob, value: u64);
    pub fn udisks_job_set_cancelable(object: *mut UDisksJob, value: gboolean);
    pub fn udisks_job_set_expected_end_time(object: *mut UDisksJob, value: u64);
    pub fn udisks_job_set_objects(object: *mut UDisksJob, value: *const *const c_char);
    pub fn udisks_job_set_operation(object: *mut UDisksJob, value: *const c_char);
    pub fn udisks_job_set_progress(object: *mut UDisksJob, value: c_double);
    pub fn udisks_job_set_progress_valid(object: *mut UDisksJob, value: gboolean);
    pub fn udisks_job_set_rate(object: *mut UDisksJob, value: u64);
    pub fn udisks_job_set_start_time(object: *mut UDisksJob, value: u64);
    pub fn udisks_job_set_started_by_uid(object: *mut UDisksJob, value: c_uint);

    //=========================================================================
    // UDisksLogicalVolume
    //=========================================================================
    pub fn udisks_logical_volume_get_type() -> GType;
    pub fn udisks_logical_volume_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_logical_volume_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_logical_volume_call_activate(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_logical_volume_call_activate_finish(proxy: *mut UDisksLogicalVolume, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_activate_sync(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_logical_volume_call_cache_attach(proxy: *mut UDisksLogicalVolume, arg_cache_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_logical_volume_call_cache_attach_finish(proxy: *mut UDisksLogicalVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_logical_volume_call_cache_attach_sync(proxy: *mut UDisksLogicalVolume, arg_cache_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_6_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_6_3")))]
    pub fn udisks_logical_volume_call_cache_detach(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_6_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_6_3")))]
    pub fn udisks_logical_volume_call_cache_detach_finish(proxy: *mut UDisksLogicalVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_6_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_6_3")))]
    pub fn udisks_logical_volume_call_cache_detach_sync(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_logical_volume_call_cache_split(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_logical_volume_call_cache_split_finish(proxy: *mut UDisksLogicalVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_logical_volume_call_cache_split_sync(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_create_snapshot(proxy: *mut UDisksLogicalVolume, arg_name: *const c_char, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_logical_volume_call_create_snapshot_finish(proxy: *mut UDisksLogicalVolume, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_create_snapshot_sync(proxy: *mut UDisksLogicalVolume, arg_name: *const c_char, arg_size: u64, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_deactivate(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_logical_volume_call_deactivate_finish(proxy: *mut UDisksLogicalVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_deactivate_sync(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_delete(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_logical_volume_call_delete_finish(proxy: *mut UDisksLogicalVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_delete_sync(proxy: *mut UDisksLogicalVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_rename(proxy: *mut UDisksLogicalVolume, arg_new_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_logical_volume_call_rename_finish(proxy: *mut UDisksLogicalVolume, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_rename_sync(proxy: *mut UDisksLogicalVolume, arg_new_name: *const c_char, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_resize(proxy: *mut UDisksLogicalVolume, arg_new_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_logical_volume_call_resize_finish(proxy: *mut UDisksLogicalVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_call_resize_sync(proxy: *mut UDisksLogicalVolume, arg_new_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_logical_volume_complete_activate(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_logical_volume_complete_cache_attach(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_6_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_6_3")))]
    pub fn udisks_logical_volume_complete_cache_detach(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_logical_volume_complete_cache_split(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_logical_volume_complete_create_snapshot(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);
    pub fn udisks_logical_volume_complete_deactivate(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_logical_volume_complete_delete(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_logical_volume_complete_rename(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);
    pub fn udisks_logical_volume_complete_resize(object: *mut UDisksLogicalVolume, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_7_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_1")))]
    pub fn udisks_logical_volume_dup_block_device(object: *mut UDisksLogicalVolume) -> *mut c_char;
    pub fn udisks_logical_volume_dup_child_configuration(object: *mut UDisksLogicalVolume) -> *mut glib::GVariant;
    pub fn udisks_logical_volume_dup_name(object: *mut UDisksLogicalVolume) -> *mut c_char;
    pub fn udisks_logical_volume_dup_origin(object: *mut UDisksLogicalVolume) -> *mut c_char;
    pub fn udisks_logical_volume_dup_thin_pool(object: *mut UDisksLogicalVolume) -> *mut c_char;
    pub fn udisks_logical_volume_dup_type_(object: *mut UDisksLogicalVolume) -> *mut c_char;
    pub fn udisks_logical_volume_dup_uuid(object: *mut UDisksLogicalVolume) -> *mut c_char;
    pub fn udisks_logical_volume_dup_volume_group(object: *mut UDisksLogicalVolume) -> *mut c_char;
    pub fn udisks_logical_volume_get_active(object: *mut UDisksLogicalVolume) -> gboolean;
    #[cfg(feature = "v2_7_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_1")))]
    pub fn udisks_logical_volume_get_block_device(object: *mut UDisksLogicalVolume) -> *const c_char;
    pub fn udisks_logical_volume_get_child_configuration(object: *mut UDisksLogicalVolume) -> *mut glib::GVariant;
    pub fn udisks_logical_volume_get_data_allocated_ratio(object: *mut UDisksLogicalVolume) -> c_double;
    pub fn udisks_logical_volume_get_metadata_allocated_ratio(object: *mut UDisksLogicalVolume) -> c_double;
    pub fn udisks_logical_volume_get_name(object: *mut UDisksLogicalVolume) -> *const c_char;
    pub fn udisks_logical_volume_get_origin(object: *mut UDisksLogicalVolume) -> *const c_char;
    pub fn udisks_logical_volume_get_size(object: *mut UDisksLogicalVolume) -> u64;
    pub fn udisks_logical_volume_get_thin_pool(object: *mut UDisksLogicalVolume) -> *const c_char;
    pub fn udisks_logical_volume_get_type_(object: *mut UDisksLogicalVolume) -> *const c_char;
    pub fn udisks_logical_volume_get_uuid(object: *mut UDisksLogicalVolume) -> *const c_char;
    pub fn udisks_logical_volume_get_volume_group(object: *mut UDisksLogicalVolume) -> *const c_char;
    pub fn udisks_logical_volume_set_active(object: *mut UDisksLogicalVolume, value: gboolean);
    #[cfg(feature = "v2_7_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_1")))]
    pub fn udisks_logical_volume_set_block_device(object: *mut UDisksLogicalVolume, value: *const c_char);
    pub fn udisks_logical_volume_set_child_configuration(object: *mut UDisksLogicalVolume, value: *mut glib::GVariant);
    pub fn udisks_logical_volume_set_data_allocated_ratio(object: *mut UDisksLogicalVolume, value: c_double);
    pub fn udisks_logical_volume_set_metadata_allocated_ratio(object: *mut UDisksLogicalVolume, value: c_double);
    pub fn udisks_logical_volume_set_name(object: *mut UDisksLogicalVolume, value: *const c_char);
    pub fn udisks_logical_volume_set_origin(object: *mut UDisksLogicalVolume, value: *const c_char);
    pub fn udisks_logical_volume_set_size(object: *mut UDisksLogicalVolume, value: u64);
    pub fn udisks_logical_volume_set_thin_pool(object: *mut UDisksLogicalVolume, value: *const c_char);
    pub fn udisks_logical_volume_set_type_(object: *mut UDisksLogicalVolume, value: *const c_char);
    pub fn udisks_logical_volume_set_uuid(object: *mut UDisksLogicalVolume, value: *const c_char);
    pub fn udisks_logical_volume_set_volume_group(object: *mut UDisksLogicalVolume, value: *const c_char);

    //=========================================================================
    // UDisksLoop
    //=========================================================================
    pub fn udisks_loop_get_type() -> GType;
    pub fn udisks_loop_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_loop_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_loop_call_delete(proxy: *mut UDisksLoop, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_loop_call_delete_finish(proxy: *mut UDisksLoop, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_loop_call_delete_sync(proxy: *mut UDisksLoop, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_loop_call_set_autoclear(proxy: *mut UDisksLoop, arg_value: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_loop_call_set_autoclear_finish(proxy: *mut UDisksLoop, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_loop_call_set_autoclear_sync(proxy: *mut UDisksLoop, arg_value: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_loop_complete_delete(object: *mut UDisksLoop, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_loop_complete_set_autoclear(object: *mut UDisksLoop, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_loop_dup_backing_file(object: *mut UDisksLoop) -> *mut c_char;
    pub fn udisks_loop_get_autoclear(object: *mut UDisksLoop) -> gboolean;
    pub fn udisks_loop_get_backing_file(object: *mut UDisksLoop) -> *const c_char;
    pub fn udisks_loop_get_setup_by_uid(object: *mut UDisksLoop) -> c_uint;
    pub fn udisks_loop_set_autoclear(object: *mut UDisksLoop, value: gboolean);
    pub fn udisks_loop_set_backing_file(object: *mut UDisksLoop, value: *const c_char);
    pub fn udisks_loop_set_setup_by_uid(object: *mut UDisksLoop, value: c_uint);

    //=========================================================================
    // UDisksMDRaid
    //=========================================================================
    pub fn udisks_mdraid_get_type() -> GType;
    pub fn udisks_mdraid_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_mdraid_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_mdraid_call_add_device(proxy: *mut UDisksMDRaid, arg_device: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_mdraid_call_add_device_finish(proxy: *mut UDisksMDRaid, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_add_device_sync(proxy: *mut UDisksMDRaid, arg_device: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_delete(proxy: *mut UDisksMDRaid, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_mdraid_call_delete_finish(proxy: *mut UDisksMDRaid, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_delete_sync(proxy: *mut UDisksMDRaid, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_remove_device(proxy: *mut UDisksMDRaid, arg_device: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_mdraid_call_remove_device_finish(proxy: *mut UDisksMDRaid, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_remove_device_sync(proxy: *mut UDisksMDRaid, arg_device: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_request_sync_action(proxy: *mut UDisksMDRaid, arg_sync_action: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_mdraid_call_request_sync_action_finish(proxy: *mut UDisksMDRaid, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_request_sync_action_sync(proxy: *mut UDisksMDRaid, arg_sync_action: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_set_bitmap_location(proxy: *mut UDisksMDRaid, arg_value: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_mdraid_call_set_bitmap_location_finish(proxy: *mut UDisksMDRaid, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_set_bitmap_location_sync(proxy: *mut UDisksMDRaid, arg_value: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_start(proxy: *mut UDisksMDRaid, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_mdraid_call_start_finish(proxy: *mut UDisksMDRaid, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_start_sync(proxy: *mut UDisksMDRaid, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_stop(proxy: *mut UDisksMDRaid, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_mdraid_call_stop_finish(proxy: *mut UDisksMDRaid, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_call_stop_sync(proxy: *mut UDisksMDRaid, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_mdraid_complete_add_device(object: *mut UDisksMDRaid, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_mdraid_complete_delete(object: *mut UDisksMDRaid, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_mdraid_complete_remove_device(object: *mut UDisksMDRaid, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_mdraid_complete_request_sync_action(object: *mut UDisksMDRaid, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_mdraid_complete_set_bitmap_location(object: *mut UDisksMDRaid, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_mdraid_complete_start(object: *mut UDisksMDRaid, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_mdraid_complete_stop(object: *mut UDisksMDRaid, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_mdraid_dup_active_devices(object: *mut UDisksMDRaid) -> *mut glib::GVariant;
    pub fn udisks_mdraid_dup_bitmap_location(object: *mut UDisksMDRaid) -> *mut c_char;
    pub fn udisks_mdraid_dup_child_configuration(object: *mut UDisksMDRaid) -> *mut glib::GVariant;
    pub fn udisks_mdraid_dup_level(object: *mut UDisksMDRaid) -> *mut c_char;
    pub fn udisks_mdraid_dup_name(object: *mut UDisksMDRaid) -> *mut c_char;
    pub fn udisks_mdraid_dup_sync_action(object: *mut UDisksMDRaid) -> *mut c_char;
    pub fn udisks_mdraid_dup_uuid(object: *mut UDisksMDRaid) -> *mut c_char;
    pub fn udisks_mdraid_get_active_devices(object: *mut UDisksMDRaid) -> *mut glib::GVariant;
    pub fn udisks_mdraid_get_bitmap_location(object: *mut UDisksMDRaid) -> *const c_char;
    pub fn udisks_mdraid_get_child_configuration(object: *mut UDisksMDRaid) -> *mut glib::GVariant;
    pub fn udisks_mdraid_get_chunk_size(object: *mut UDisksMDRaid) -> u64;
    pub fn udisks_mdraid_get_degraded(object: *mut UDisksMDRaid) -> c_uint;
    pub fn udisks_mdraid_get_level(object: *mut UDisksMDRaid) -> *const c_char;
    pub fn udisks_mdraid_get_name(object: *mut UDisksMDRaid) -> *const c_char;
    pub fn udisks_mdraid_get_num_devices(object: *mut UDisksMDRaid) -> c_uint;
    pub fn udisks_mdraid_get_running(object: *mut UDisksMDRaid) -> gboolean;
    pub fn udisks_mdraid_get_size(object: *mut UDisksMDRaid) -> u64;
    pub fn udisks_mdraid_get_sync_action(object: *mut UDisksMDRaid) -> *const c_char;
    pub fn udisks_mdraid_get_sync_completed(object: *mut UDisksMDRaid) -> c_double;
    pub fn udisks_mdraid_get_sync_rate(object: *mut UDisksMDRaid) -> u64;
    pub fn udisks_mdraid_get_sync_remaining_time(object: *mut UDisksMDRaid) -> u64;
    pub fn udisks_mdraid_get_uuid(object: *mut UDisksMDRaid) -> *const c_char;
    pub fn udisks_mdraid_set_active_devices(object: *mut UDisksMDRaid, value: *mut glib::GVariant);
    pub fn udisks_mdraid_set_bitmap_location(object: *mut UDisksMDRaid, value: *const c_char);
    pub fn udisks_mdraid_set_child_configuration(object: *mut UDisksMDRaid, value: *mut glib::GVariant);
    pub fn udisks_mdraid_set_chunk_size(object: *mut UDisksMDRaid, value: u64);
    pub fn udisks_mdraid_set_degraded(object: *mut UDisksMDRaid, value: c_uint);
    pub fn udisks_mdraid_set_level(object: *mut UDisksMDRaid, value: *const c_char);
    pub fn udisks_mdraid_set_name(object: *mut UDisksMDRaid, value: *const c_char);
    pub fn udisks_mdraid_set_num_devices(object: *mut UDisksMDRaid, value: c_uint);
    pub fn udisks_mdraid_set_running(object: *mut UDisksMDRaid, value: gboolean);
    pub fn udisks_mdraid_set_size(object: *mut UDisksMDRaid, value: u64);
    pub fn udisks_mdraid_set_sync_action(object: *mut UDisksMDRaid, value: *const c_char);
    pub fn udisks_mdraid_set_sync_completed(object: *mut UDisksMDRaid, value: c_double);
    pub fn udisks_mdraid_set_sync_rate(object: *mut UDisksMDRaid, value: u64);
    pub fn udisks_mdraid_set_sync_remaining_time(object: *mut UDisksMDRaid, value: u64);
    pub fn udisks_mdraid_set_uuid(object: *mut UDisksMDRaid, value: *const c_char);

    //=========================================================================
    // UDisksManager
    //=========================================================================
    pub fn udisks_manager_get_type() -> GType;
    pub fn udisks_manager_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_manager_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_check(proxy: *mut UDisksManager, arg_type: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_check_finish(proxy: *mut UDisksManager, out_available: *mut *mut glib::GVariant, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_check_sync(proxy: *mut UDisksManager, arg_type: *const c_char, out_available: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_format(proxy: *mut UDisksManager, arg_type: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_format_finish(proxy: *mut UDisksManager, out_available: *mut *mut glib::GVariant, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_format_sync(proxy: *mut UDisksManager, arg_type: *const c_char, out_available: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_repair(proxy: *mut UDisksManager, arg_type: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_repair_finish(proxy: *mut UDisksManager, out_available: *mut *mut glib::GVariant, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_repair_sync(proxy: *mut UDisksManager, arg_type: *const c_char, out_available: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_resize(proxy: *mut UDisksManager, arg_type: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_resize_finish(proxy: *mut UDisksManager, out_available: *mut *mut glib::GVariant, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_can_resize_sync(proxy: *mut UDisksManager, arg_type: *const c_char, out_available: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_manager_call_enable_module(proxy: *mut UDisksManager, arg_name: *const c_char, arg_enable: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_manager_call_enable_module_finish(proxy: *mut UDisksManager, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_manager_call_enable_module_sync(proxy: *mut UDisksManager, arg_name: *const c_char, arg_enable: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_manager_call_enable_modules(proxy: *mut UDisksManager, arg_enable: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_manager_call_enable_modules_finish(proxy: *mut UDisksManager, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_manager_call_enable_modules_sync(proxy: *mut UDisksManager, arg_enable: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_get_block_devices(proxy: *mut UDisksManager, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_get_block_devices_finish(proxy: *mut UDisksManager, out_block_objects: *mut *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_call_get_block_devices_sync(proxy: *mut UDisksManager, arg_options: *mut glib::GVariant, out_block_objects: *mut *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_manager_call_loop_setup(proxy: *mut UDisksManager, arg_fd: *mut glib::GVariant, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_manager_call_loop_setup_finish(proxy: *mut UDisksManager, out_resulting_device: *mut *mut c_char, out_fd_list: *mut *mut gio::GUnixFDList, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_manager_call_loop_setup_sync(proxy: *mut UDisksManager, arg_fd: *mut glib::GVariant, arg_options: *mut glib::GVariant, fd_list: *mut gio::GUnixFDList, out_resulting_device: *mut *mut c_char, out_fd_list: *mut *mut gio::GUnixFDList, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_manager_call_mdraid_create(proxy: *mut UDisksManager, arg_blocks: *const *const c_char, arg_level: *const c_char, arg_name: *const c_char, arg_chunk: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_manager_call_mdraid_create_finish(proxy: *mut UDisksManager, out_resulting_array: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_manager_call_mdraid_create_sync(proxy: *mut UDisksManager, arg_blocks: *const *const c_char, arg_level: *const c_char, arg_name: *const c_char, arg_chunk: u64, arg_options: *mut glib::GVariant, out_resulting_array: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    pub fn udisks_manager_call_resolve_device(proxy: *mut UDisksManager, arg_devspec: *mut glib::GVariant, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_7_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    pub fn udisks_manager_call_resolve_device_finish(proxy: *mut UDisksManager, out_devices: *mut *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    pub fn udisks_manager_call_resolve_device_sync(proxy: *mut UDisksManager, arg_devspec: *mut glib::GVariant, arg_options: *mut glib::GVariant, out_devices: *mut *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_complete_can_check(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation, available: *mut glib::GVariant);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_complete_can_format(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation, available: *mut glib::GVariant);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_complete_can_repair(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation, available: *mut glib::GVariant);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_complete_can_resize(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation, available: *mut glib::GVariant);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_manager_complete_enable_module(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_manager_complete_enable_modules(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_2")))]
    pub fn udisks_manager_complete_get_block_devices(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation, block_objects: *const *const c_char);
    pub fn udisks_manager_complete_loop_setup(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation, fd_list: *mut gio::GUnixFDList, resulting_device: *const c_char);
    pub fn udisks_manager_complete_mdraid_create(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation, resulting_array: *const c_char);
    #[cfg(feature = "v2_7_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_7_3")))]
    pub fn udisks_manager_complete_resolve_device(object: *mut UDisksManager, invocation: *mut gio::GDBusMethodInvocation, devices: *const *const c_char);
    pub fn udisks_manager_dup_default_encryption_type(object: *mut UDisksManager) -> *mut c_char;
    pub fn udisks_manager_dup_supported_encryption_types(object: *mut UDisksManager) -> *mut *mut c_char;
    pub fn udisks_manager_dup_supported_filesystems(object: *mut UDisksManager) -> *mut *mut c_char;
    pub fn udisks_manager_dup_version(object: *mut UDisksManager) -> *mut c_char;
    pub fn udisks_manager_get_default_encryption_type(object: *mut UDisksManager) -> *const c_char;
    pub fn udisks_manager_get_supported_encryption_types(object: *mut UDisksManager) -> *const *const c_char;
    pub fn udisks_manager_get_supported_filesystems(object: *mut UDisksManager) -> *const *const c_char;
    pub fn udisks_manager_get_version(object: *mut UDisksManager) -> *const c_char;
    pub fn udisks_manager_set_default_encryption_type(object: *mut UDisksManager, value: *const c_char);
    pub fn udisks_manager_set_supported_encryption_types(object: *mut UDisksManager, value: *const *const c_char);
    pub fn udisks_manager_set_supported_filesystems(object: *mut UDisksManager, value: *const *const c_char);
    pub fn udisks_manager_set_version(object: *mut UDisksManager, value: *const c_char);

    //=========================================================================
    // UDisksManagerBTRFS
    //=========================================================================
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_get_type() -> GType;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_interface_info() -> *mut gio::GDBusInterfaceInfo;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_manager_btrfs_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_manager_btrfs_call_create_volume(proxy: *mut UDisksManagerBTRFS, arg_devices: *const *const c_char, arg_label: *const c_char, arg_data_level: *const c_char, arg_md_level: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_manager_btrfs_call_create_volume_finish(proxy: *mut UDisksManagerBTRFS, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_manager_btrfs_call_create_volume_sync(proxy: *mut UDisksManagerBTRFS, arg_devices: *const *const c_char, arg_label: *const c_char, arg_data_level: *const c_char, arg_md_level: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_3")))]
    pub fn udisks_manager_btrfs_complete_create_volume(object: *mut UDisksManagerBTRFS, invocation: *mut gio::GDBusMethodInvocation);

    //=========================================================================
    // UDisksManagerLVM2
    //=========================================================================
    pub fn udisks_manager_lvm2_get_type() -> GType;
    pub fn udisks_manager_lvm2_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_manager_lvm2_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_manager_lvm2_call_volume_group_create(proxy: *mut UDisksManagerLVM2, arg_name: *const c_char, arg_blocks: *const *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_manager_lvm2_call_volume_group_create_finish(proxy: *mut UDisksManagerLVM2, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_manager_lvm2_call_volume_group_create_sync(proxy: *mut UDisksManagerLVM2, arg_name: *const c_char, arg_blocks: *const *const c_char, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_manager_lvm2_complete_volume_group_create(object: *mut UDisksManagerLVM2, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);

    //=========================================================================
    // UDisksObject
    //=========================================================================
    pub fn udisks_object_get_type() -> GType;
    pub fn udisks_object_get_block(object: *mut UDisksObject) -> *mut UDisksBlock;
    pub fn udisks_object_get_block_lvm2(object: *mut UDisksObject) -> *mut UDisksBlockLVM2;
    pub fn udisks_object_get_drive(object: *mut UDisksObject) -> *mut UDisksDrive;
    pub fn udisks_object_get_drive_ata(object: *mut UDisksObject) -> *mut UDisksDriveAta;
    pub fn udisks_object_get_encrypted(object: *mut UDisksObject) -> *mut UDisksEncrypted;
    pub fn udisks_object_get_filesystem(object: *mut UDisksObject) -> *mut UDisksFilesystem;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_object_get_filesystem_btrfs(object: *mut UDisksObject) -> *mut UDisksFilesystemBTRFS;
    pub fn udisks_object_get_job(object: *mut UDisksObject) -> *mut UDisksJob;
    pub fn udisks_object_get_logical_volume(object: *mut UDisksObject) -> *mut UDisksLogicalVolume;
    pub fn udisks_object_get_loop(object: *mut UDisksObject) -> *mut UDisksLoop;
    pub fn udisks_object_get_manager(object: *mut UDisksObject) -> *mut UDisksManager;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_object_get_manager_btrfs(object: *mut UDisksObject) -> *mut UDisksManagerBTRFS;
    pub fn udisks_object_get_manager_lvm2(object: *mut UDisksObject) -> *mut UDisksManagerLVM2;
    pub fn udisks_object_get_mdraid(object: *mut UDisksObject) -> *mut UDisksMDRaid;
    pub fn udisks_object_get_partition(object: *mut UDisksObject) -> *mut UDisksPartition;
    pub fn udisks_object_get_partition_table(object: *mut UDisksObject) -> *mut UDisksPartitionTable;
    pub fn udisks_object_get_physical_volume(object: *mut UDisksObject) -> *mut UDisksPhysicalVolume;
    pub fn udisks_object_get_swapspace(object: *mut UDisksObject) -> *mut UDisksSwapspace;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_object_get_vdo_volume(object: *mut UDisksObject) -> *mut UDisksVDOVolume;
    pub fn udisks_object_get_volume_group(object: *mut UDisksObject) -> *mut UDisksVolumeGroup;
    pub fn udisks_object_peek_block(object: *mut UDisksObject) -> *mut UDisksBlock;
    pub fn udisks_object_peek_block_lvm2(object: *mut UDisksObject) -> *mut UDisksBlockLVM2;
    pub fn udisks_object_peek_drive(object: *mut UDisksObject) -> *mut UDisksDrive;
    pub fn udisks_object_peek_drive_ata(object: *mut UDisksObject) -> *mut UDisksDriveAta;
    pub fn udisks_object_peek_encrypted(object: *mut UDisksObject) -> *mut UDisksEncrypted;
    pub fn udisks_object_peek_filesystem(object: *mut UDisksObject) -> *mut UDisksFilesystem;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_object_peek_filesystem_btrfs(object: *mut UDisksObject) -> *mut UDisksFilesystemBTRFS;
    pub fn udisks_object_peek_job(object: *mut UDisksObject) -> *mut UDisksJob;
    pub fn udisks_object_peek_logical_volume(object: *mut UDisksObject) -> *mut UDisksLogicalVolume;
    pub fn udisks_object_peek_loop(object: *mut UDisksObject) -> *mut UDisksLoop;
    pub fn udisks_object_peek_manager(object: *mut UDisksObject) -> *mut UDisksManager;
    #[cfg(feature = "v2_1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_1_3")))]
    pub fn udisks_object_peek_manager_btrfs(object: *mut UDisksObject) -> *mut UDisksManagerBTRFS;
    pub fn udisks_object_peek_manager_lvm2(object: *mut UDisksObject) -> *mut UDisksManagerLVM2;
    pub fn udisks_object_peek_mdraid(object: *mut UDisksObject) -> *mut UDisksMDRaid;
    pub fn udisks_object_peek_partition(object: *mut UDisksObject) -> *mut UDisksPartition;
    pub fn udisks_object_peek_partition_table(object: *mut UDisksObject) -> *mut UDisksPartitionTable;
    pub fn udisks_object_peek_physical_volume(object: *mut UDisksObject) -> *mut UDisksPhysicalVolume;
    pub fn udisks_object_peek_swapspace(object: *mut UDisksObject) -> *mut UDisksSwapspace;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_object_peek_vdo_volume(object: *mut UDisksObject) -> *mut UDisksVDOVolume;
    pub fn udisks_object_peek_volume_group(object: *mut UDisksObject) -> *mut UDisksVolumeGroup;

    //=========================================================================
    // UDisksPartition
    //=========================================================================
    pub fn udisks_partition_get_type() -> GType;
    pub fn udisks_partition_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_partition_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_partition_call_delete(proxy: *mut UDisksPartition, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_call_delete_finish(proxy: *mut UDisksPartition, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_delete_sync(proxy: *mut UDisksPartition, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_resize(proxy: *mut UDisksPartition, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_call_resize_finish(proxy: *mut UDisksPartition, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_resize_sync(proxy: *mut UDisksPartition, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_set_flags(proxy: *mut UDisksPartition, arg_flags: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_call_set_flags_finish(proxy: *mut UDisksPartition, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_set_flags_sync(proxy: *mut UDisksPartition, arg_flags: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_set_name(proxy: *mut UDisksPartition, arg_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_call_set_name_finish(proxy: *mut UDisksPartition, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_set_name_sync(proxy: *mut UDisksPartition, arg_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_set_type(proxy: *mut UDisksPartition, arg_type: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_call_set_type_finish(proxy: *mut UDisksPartition, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_call_set_type_sync(proxy: *mut UDisksPartition, arg_type: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_complete_delete(object: *mut UDisksPartition, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_partition_complete_resize(object: *mut UDisksPartition, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_partition_complete_set_flags(object: *mut UDisksPartition, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_partition_complete_set_name(object: *mut UDisksPartition, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_partition_complete_set_type(object: *mut UDisksPartition, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_partition_dup_name(object: *mut UDisksPartition) -> *mut c_char;
    pub fn udisks_partition_dup_table(object: *mut UDisksPartition) -> *mut c_char;
    pub fn udisks_partition_dup_type_(object: *mut UDisksPartition) -> *mut c_char;
    pub fn udisks_partition_dup_uuid(object: *mut UDisksPartition) -> *mut c_char;
    pub fn udisks_partition_get_flags(object: *mut UDisksPartition) -> u64;
    pub fn udisks_partition_get_is_contained(object: *mut UDisksPartition) -> gboolean;
    pub fn udisks_partition_get_is_container(object: *mut UDisksPartition) -> gboolean;
    pub fn udisks_partition_get_name(object: *mut UDisksPartition) -> *const c_char;
    pub fn udisks_partition_get_number(object: *mut UDisksPartition) -> c_uint;
    pub fn udisks_partition_get_offset(object: *mut UDisksPartition) -> u64;
    pub fn udisks_partition_get_size(object: *mut UDisksPartition) -> u64;
    pub fn udisks_partition_get_table(object: *mut UDisksPartition) -> *const c_char;
    pub fn udisks_partition_get_type_(object: *mut UDisksPartition) -> *const c_char;
    pub fn udisks_partition_get_uuid(object: *mut UDisksPartition) -> *const c_char;
    pub fn udisks_partition_set_flags(object: *mut UDisksPartition, value: u64);
    pub fn udisks_partition_set_is_contained(object: *mut UDisksPartition, value: gboolean);
    pub fn udisks_partition_set_is_container(object: *mut UDisksPartition, value: gboolean);
    pub fn udisks_partition_set_name(object: *mut UDisksPartition, value: *const c_char);
    pub fn udisks_partition_set_number(object: *mut UDisksPartition, value: c_uint);
    pub fn udisks_partition_set_offset(object: *mut UDisksPartition, value: u64);
    pub fn udisks_partition_set_size(object: *mut UDisksPartition, value: u64);
    pub fn udisks_partition_set_table(object: *mut UDisksPartition, value: *const c_char);
    pub fn udisks_partition_set_type_(object: *mut UDisksPartition, value: *const c_char);
    pub fn udisks_partition_set_uuid(object: *mut UDisksPartition, value: *const c_char);

    //=========================================================================
    // UDisksPartitionTable
    //=========================================================================
    pub fn udisks_partition_table_get_type() -> GType;
    pub fn udisks_partition_table_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_partition_table_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_partition_table_call_create_partition(proxy: *mut UDisksPartitionTable, arg_offset: u64, arg_size: u64, arg_type: *const c_char, arg_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_table_call_create_partition_and_format(proxy: *mut UDisksPartitionTable, arg_offset: u64, arg_size: u64, arg_type: *const c_char, arg_name: *const c_char, arg_options: *mut glib::GVariant, arg_format_type: *const c_char, arg_format_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_partition_table_call_create_partition_and_format_finish(proxy: *mut UDisksPartitionTable, out_created_partition: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_table_call_create_partition_and_format_sync(proxy: *mut UDisksPartitionTable, arg_offset: u64, arg_size: u64, arg_type: *const c_char, arg_name: *const c_char, arg_options: *mut glib::GVariant, arg_format_type: *const c_char, arg_format_options: *mut glib::GVariant, out_created_partition: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_table_call_create_partition_finish(proxy: *mut UDisksPartitionTable, out_created_partition: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_table_call_create_partition_sync(proxy: *mut UDisksPartitionTable, arg_offset: u64, arg_size: u64, arg_type: *const c_char, arg_name: *const c_char, arg_options: *mut glib::GVariant, out_created_partition: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_partition_table_complete_create_partition(object: *mut UDisksPartitionTable, invocation: *mut gio::GDBusMethodInvocation, created_partition: *const c_char);
    pub fn udisks_partition_table_complete_create_partition_and_format(object: *mut UDisksPartitionTable, invocation: *mut gio::GDBusMethodInvocation, created_partition: *const c_char);
    pub fn udisks_partition_table_dup_partitions(object: *mut UDisksPartitionTable) -> *mut *mut c_char;
    pub fn udisks_partition_table_dup_type_(object: *mut UDisksPartitionTable) -> *mut c_char;
    pub fn udisks_partition_table_get_partitions(object: *mut UDisksPartitionTable) -> *const *const c_char;
    pub fn udisks_partition_table_get_type_(object: *mut UDisksPartitionTable) -> *const c_char;
    pub fn udisks_partition_table_set_partitions(object: *mut UDisksPartitionTable, value: *const *const c_char);
    pub fn udisks_partition_table_set_type_(object: *mut UDisksPartitionTable, value: *const c_char);

    //=========================================================================
    // UDisksPhysicalVolume
    //=========================================================================
    pub fn udisks_physical_volume_get_type() -> GType;
    pub fn udisks_physical_volume_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_physical_volume_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_physical_volume_dup_volume_group(object: *mut UDisksPhysicalVolume) -> *mut c_char;
    pub fn udisks_physical_volume_get_free_size(object: *mut UDisksPhysicalVolume) -> u64;
    pub fn udisks_physical_volume_get_size(object: *mut UDisksPhysicalVolume) -> u64;
    pub fn udisks_physical_volume_get_volume_group(object: *mut UDisksPhysicalVolume) -> *const c_char;
    pub fn udisks_physical_volume_set_free_size(object: *mut UDisksPhysicalVolume, value: u64);
    pub fn udisks_physical_volume_set_size(object: *mut UDisksPhysicalVolume, value: u64);
    pub fn udisks_physical_volume_set_volume_group(object: *mut UDisksPhysicalVolume, value: *const c_char);

    //=========================================================================
    // UDisksSwapspace
    //=========================================================================
    pub fn udisks_swapspace_get_type() -> GType;
    pub fn udisks_swapspace_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_swapspace_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_swapspace_call_set_label(proxy: *mut UDisksSwapspace, arg_label: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_swapspace_call_set_label_finish(proxy: *mut UDisksSwapspace, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_swapspace_call_set_label_sync(proxy: *mut UDisksSwapspace, arg_label: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_swapspace_call_start(proxy: *mut UDisksSwapspace, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_swapspace_call_start_finish(proxy: *mut UDisksSwapspace, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_swapspace_call_start_sync(proxy: *mut UDisksSwapspace, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_swapspace_call_stop(proxy: *mut UDisksSwapspace, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_swapspace_call_stop_finish(proxy: *mut UDisksSwapspace, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_swapspace_call_stop_sync(proxy: *mut UDisksSwapspace, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_swapspace_complete_set_label(object: *mut UDisksSwapspace, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_swapspace_complete_start(object: *mut UDisksSwapspace, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_swapspace_complete_stop(object: *mut UDisksSwapspace, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_swapspace_get_active(object: *mut UDisksSwapspace) -> gboolean;
    pub fn udisks_swapspace_set_active(object: *mut UDisksSwapspace, value: gboolean);

    //=========================================================================
    // UDisksVDOVolume
    //=========================================================================
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_get_type() -> GType;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_interface_info() -> *mut gio::GDBusInterfaceInfo;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_enable_compression(proxy: *mut UDisksVDOVolume, arg_enable: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_enable_compression_finish(proxy: *mut UDisksVDOVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_enable_compression_sync(proxy: *mut UDisksVDOVolume, arg_enable: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_enable_deduplication(proxy: *mut UDisksVDOVolume, arg_enable: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_enable_deduplication_finish(proxy: *mut UDisksVDOVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_enable_deduplication_sync(proxy: *mut UDisksVDOVolume, arg_enable: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_get_statistics(proxy: *mut UDisksVDOVolume, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_get_statistics_finish(proxy: *mut UDisksVDOVolume, out_stats: *mut *mut glib::GVariant, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_get_statistics_sync(proxy: *mut UDisksVDOVolume, arg_options: *mut glib::GVariant, out_stats: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_resize_logical(proxy: *mut UDisksVDOVolume, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_resize_logical_finish(proxy: *mut UDisksVDOVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_resize_logical_sync(proxy: *mut UDisksVDOVolume, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_resize_physical(proxy: *mut UDisksVDOVolume, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_resize_physical_finish(proxy: *mut UDisksVDOVolume, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_call_resize_physical_sync(proxy: *mut UDisksVDOVolume, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_complete_enable_compression(object: *mut UDisksVDOVolume, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_complete_enable_deduplication(object: *mut UDisksVDOVolume, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_complete_get_statistics(object: *mut UDisksVDOVolume, invocation: *mut gio::GDBusMethodInvocation, stats: *mut glib::GVariant);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_complete_resize_logical(object: *mut UDisksVDOVolume, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_complete_resize_physical(object: *mut UDisksVDOVolume, invocation: *mut gio::GDBusMethodInvocation);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_dup_compression_state(object: *mut UDisksVDOVolume) -> *mut c_char;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_dup_index_state(object: *mut UDisksVDOVolume) -> *mut c_char;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_dup_operating_mode(object: *mut UDisksVDOVolume) -> *mut c_char;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_dup_vdo_pool(object: *mut UDisksVDOVolume) -> *mut c_char;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_get_compression(object: *mut UDisksVDOVolume) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_get_compression_state(object: *mut UDisksVDOVolume) -> *const c_char;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_get_deduplication(object: *mut UDisksVDOVolume) -> gboolean;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_get_index_state(object: *mut UDisksVDOVolume) -> *const c_char;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_get_operating_mode(object: *mut UDisksVDOVolume) -> *const c_char;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_get_used_size(object: *mut UDisksVDOVolume) -> u64;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_get_vdo_pool(object: *mut UDisksVDOVolume) -> *const c_char;
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_set_compression(object: *mut UDisksVDOVolume, value: gboolean);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_set_compression_state(object: *mut UDisksVDOVolume, value: *const c_char);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_set_deduplication(object: *mut UDisksVDOVolume, value: gboolean);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_set_index_state(object: *mut UDisksVDOVolume, value: *const c_char);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_set_operating_mode(object: *mut UDisksVDOVolume, value: *const c_char);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_set_used_size(object: *mut UDisksVDOVolume, value: u64);
    #[cfg(feature = "v2_9")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v2_9")))]
    pub fn udisks_vdo_volume_set_vdo_pool(object: *mut UDisksVDOVolume, value: *const c_char);

    //=========================================================================
    // UDisksVolumeGroup
    //=========================================================================
    pub fn udisks_volume_group_get_type() -> GType;
    pub fn udisks_volume_group_interface_info() -> *mut gio::GDBusInterfaceInfo;
    pub fn udisks_volume_group_override_properties(klass: *mut gobject::GObjectClass, property_id_begin: c_uint) -> c_uint;
    pub fn udisks_volume_group_call_add_device(proxy: *mut UDisksVolumeGroup, arg_block: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_add_device_finish(proxy: *mut UDisksVolumeGroup, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_add_device_sync(proxy: *mut UDisksVolumeGroup, arg_block: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_create_plain_volume(proxy: *mut UDisksVolumeGroup, arg_name: *const c_char, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_create_plain_volume_finish(proxy: *mut UDisksVolumeGroup, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_create_plain_volume_sync(proxy: *mut UDisksVolumeGroup, arg_name: *const c_char, arg_size: u64, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_create_thin_pool_volume(proxy: *mut UDisksVolumeGroup, arg_name: *const c_char, arg_size: u64, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_create_thin_pool_volume_finish(proxy: *mut UDisksVolumeGroup, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_create_thin_pool_volume_sync(proxy: *mut UDisksVolumeGroup, arg_name: *const c_char, arg_size: u64, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_create_thin_volume(proxy: *mut UDisksVolumeGroup, arg_name: *const c_char, arg_size: u64, arg_pool: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_create_thin_volume_finish(proxy: *mut UDisksVolumeGroup, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_create_thin_volume_sync(proxy: *mut UDisksVolumeGroup, arg_name: *const c_char, arg_size: u64, arg_pool: *const c_char, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_create_vdo_volume(proxy: *mut UDisksVolumeGroup, arg_lv_name: *const c_char, arg_pool_name: *const c_char, arg_data_size: u64, arg_virtual_size: u64, arg_index_memory: u64, arg_compression: gboolean, arg_deduplication: gboolean, arg_write_policy: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_create_vdo_volume_finish(proxy: *mut UDisksVolumeGroup, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_create_vdo_volume_sync(proxy: *mut UDisksVolumeGroup, arg_lv_name: *const c_char, arg_pool_name: *const c_char, arg_data_size: u64, arg_virtual_size: u64, arg_index_memory: u64, arg_compression: gboolean, arg_deduplication: gboolean, arg_write_policy: *const c_char, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_delete(proxy: *mut UDisksVolumeGroup, arg_wipe: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_delete_finish(proxy: *mut UDisksVolumeGroup, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_delete_sync(proxy: *mut UDisksVolumeGroup, arg_wipe: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_empty_device(proxy: *mut UDisksVolumeGroup, arg_block: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_empty_device_finish(proxy: *mut UDisksVolumeGroup, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_empty_device_sync(proxy: *mut UDisksVolumeGroup, arg_block: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_poll(proxy: *mut UDisksVolumeGroup, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_poll_finish(proxy: *mut UDisksVolumeGroup, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_poll_sync(proxy: *mut UDisksVolumeGroup, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_remove_device(proxy: *mut UDisksVolumeGroup, arg_block: *const c_char, arg_wipe: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_remove_device_finish(proxy: *mut UDisksVolumeGroup, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_remove_device_sync(proxy: *mut UDisksVolumeGroup, arg_block: *const c_char, arg_wipe: gboolean, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_rename(proxy: *mut UDisksVolumeGroup, arg_new_name: *const c_char, arg_options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn udisks_volume_group_call_rename_finish(proxy: *mut UDisksVolumeGroup, out_result: *mut *mut c_char, res: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_call_rename_sync(proxy: *mut UDisksVolumeGroup, arg_new_name: *const c_char, arg_options: *mut glib::GVariant, out_result: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn udisks_volume_group_complete_add_device(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_volume_group_complete_create_plain_volume(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);
    pub fn udisks_volume_group_complete_create_thin_pool_volume(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);
    pub fn udisks_volume_group_complete_create_thin_volume(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);
    pub fn udisks_volume_group_complete_create_vdo_volume(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);
    pub fn udisks_volume_group_complete_delete(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_volume_group_complete_empty_device(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_volume_group_complete_poll(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_volume_group_complete_remove_device(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation);
    pub fn udisks_volume_group_complete_rename(object: *mut UDisksVolumeGroup, invocation: *mut gio::GDBusMethodInvocation, result: *const c_char);
    pub fn udisks_volume_group_dup_name(object: *mut UDisksVolumeGroup) -> *mut c_char;
    pub fn udisks_volume_group_dup_uuid(object: *mut UDisksVolumeGroup) -> *mut c_char;
    pub fn udisks_volume_group_get_extent_size(object: *mut UDisksVolumeGroup) -> u64;
    pub fn udisks_volume_group_get_free_size(object: *mut UDisksVolumeGroup) -> u64;
    pub fn udisks_volume_group_get_name(object: *mut UDisksVolumeGroup) -> *const c_char;
    pub fn udisks_volume_group_get_needs_polling(object: *mut UDisksVolumeGroup) -> gboolean;
    pub fn udisks_volume_group_get_size(object: *mut UDisksVolumeGroup) -> u64;
    pub fn udisks_volume_group_get_uuid(object: *mut UDisksVolumeGroup) -> *const c_char;
    pub fn udisks_volume_group_set_extent_size(object: *mut UDisksVolumeGroup, value: u64);
    pub fn udisks_volume_group_set_free_size(object: *mut UDisksVolumeGroup, value: u64);
    pub fn udisks_volume_group_set_name(object: *mut UDisksVolumeGroup, value: *const c_char);
    pub fn udisks_volume_group_set_needs_polling(object: *mut UDisksVolumeGroup, value: gboolean);
    pub fn udisks_volume_group_set_size(object: *mut UDisksVolumeGroup, value: u64);
    pub fn udisks_volume_group_set_uuid(object: *mut UDisksVolumeGroup, value: *const c_char);

}
