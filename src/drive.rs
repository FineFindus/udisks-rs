//! # DBus interface proxy for: `org.freedesktop.UDisks2.Drive`
//!
//! This code was generated by `zbus-xmlgen` `4.0.0` from DBus introspection data.
//! Source: `org.freedesktop.UDisks2.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus2.github.io/zbus/client.html)
//! section of the zbus documentation.
//!

use std::str::FromStr;

use serde::{de::IntoDeserializer, Deserialize, Serialize};
use zbus::{
    proxy,
    zvariant::{OwnedValue, Type, Value},
};

use crate::error;

/// Rotational rate of a drive.
#[derive(Debug, Default, PartialEq, Eq)]
pub enum RotationRate {
    /// The drive is known to be rotating media but rotation rate isn't known.
    Unknown,
    /// The drive is known to be non-rotating media.
    #[default]
    NonRotating,
    /// The rotation rate in rounds per minute.
    Rotating(i32),
}

impl TryFrom<OwnedValue> for RotationRate {
    type Error = <i32 as TryFrom<OwnedValue>>::Error;

    fn try_from(v: OwnedValue) -> Result<Self, Self::Error> {
        Ok(match v.try_into()? {
            -1 => RotationRate::Unknown,
            0 => RotationRate::NonRotating,
            v => RotationRate::Rotating(v),
        })
    }
}

/// The physical kind of media a drive uses or the type of the drive.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize, Eq, Type)]
#[zvariant(signature = "s")]
#[serde(rename_all = "snake_case")]
#[non_exhaustive]
pub enum MediaCompatibility {
    /// The device is a thumb-drive with non-removable media (e.g. a USB stick)
    Thumb,
    /// Flash Card
    Flash,
    /// CompactFlash
    FlashCf,
    /// MemoryStick
    FlashMs,
    /// SmartMedia
    FlashSm,
    /// Secure Digital
    FlashSd,
    /// Secure Digital High Capacity
    FlashSdhc,
    /// Secure Digital eXtended Capacity
    FlashSdxc,
    /// Secure Digital Input Output
    FlashSdio,
    /// Secure Digital Input Output combo card with storage and I/O functionality
    FlashSdCombo,
    /// MultiMediaCard
    FlashMmc,
    /// Floppy Disk
    Floppy,
    /// Zip Disk
    FloppyZip,
    /// Jaz Disk
    FloppyJaz,
    /// Optical Disc
    Optical,
    /// Compact Disc
    OpticalCd,
    /// Compact Disc Recordable
    OpticalCdR,
    /// Compact Disc Rewritable
    OpticalCdRw,
    /// Digital Versatile Disc
    OpticalDvd,
    /// DVD-R
    OpticalDvdR,
    /// DVD-RW
    OpticalDvdRw,
    /// DVD-RAM
    OpticalDvdRam,
    /// DVD+R
    OpticalDvdPlusR,
    /// DVD+RW
    OpticalDvdPlusRw,
    /// DVD+R Dual Layer
    OpticalDvdPlusRDl,
    /// DVD+RW Dual Layer
    OpticalDvdPlusRwDl,
    /// Blu-ray Disc
    OpticalBd,
    /// Blu-ray Recordable
    OpticalBdR,
    /// Blu-ray Rewritable
    OpticalBdRe,
    /// HD-DVD
    OpticalHddvd,
    /// HD-DVD Recordable
    OpticalHddvdR,
    /// HD-DVD Rewritable
    OpticalHddvdRw,
    /// Magneto Optical
    OpticalMo,
    /// Can read Mount Rainer media
    OpticalMrw,
    /// Can write Mount Rainer media
    OpticalMrwW,
    /// Media is unknown
    #[serde(rename(deserialize = ""))] // unknow types are blank
    Unknown,
}

impl FromStr for MediaCompatibility {
    type Err = serde::de::value::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let res: Result<_, Self::Err> = Self::deserialize(s.into_deserializer());
        Ok(res.unwrap_or(Self::Unknown))
    }
}

// TODO: why isn't this working just using pro macros
impl TryFrom<Value<'_>> for MediaCompatibility {
    type Error = <String as TryFrom<Value<'static>>>::Error;

    fn try_from(value: Value<'_>) -> Result<Self, Self::Error> {
        let val: String = value.downcast_ref()?;
        Ok(Self::from_str(&val).unwrap_or(Self::Unknown))
    }
}

impl TryFrom<OwnedValue> for MediaCompatibility {
    type Error = <String as TryFrom<OwnedValue>>::Error;

    fn try_from(v: OwnedValue) -> Result<Self, Self::Error> {
        Self::try_from(Into::<Value<'_>>::into(v))
    }
}

#[proxy(
    interface = "org.freedesktop.UDisks2.Drive",
    default_service = "org.freedesktop.UDisks2",
    default_path = "/org/freedesktop/UDisks2/Drive"
)]
trait Drive {
    /// Eject method
    fn eject(
        &self,
        options: std::collections::HashMap<&str, zbus::zvariant::Value<'_>>,
    ) -> error::Result<()>;

    /// PowerOff method
    fn power_off(
        &self,
        options: std::collections::HashMap<&str, zbus::zvariant::Value<'_>>,
    ) -> error::Result<()>;

    /// SetConfiguration method
    fn set_configuration(
        &self,
        value: std::collections::HashMap<&str, zbus::zvariant::Value<'_>>,
        options: std::collections::HashMap<&str, zbus::zvariant::Value<'_>>,
    ) -> error::Result<()>;

    /// CanPowerOff property
    #[zbus(property)]
    fn can_power_off(&self) -> error::Result<bool>;

    /// Configuration property
    #[zbus(property)]
    fn configuration(
        &self,
    ) -> error::Result<std::collections::HashMap<String, zbus::zvariant::OwnedValue>>;

    /// ConnectionBus property
    #[zbus(property)]
    fn connection_bus(&self) -> error::Result<String>;

    /// Ejectable property
    #[zbus(property)]
    fn ejectable(&self) -> error::Result<bool>;

    /// Id property
    #[zbus(property)]
    fn id(&self) -> error::Result<String>;

    /// Media property
    #[zbus(property)]
    fn media(&self) -> error::Result<MediaCompatibility>;

    /// MediaAvailable property
    #[zbus(property)]
    fn media_available(&self) -> error::Result<bool>;

    /// MediaChangeDetected property
    #[zbus(property)]
    fn media_change_detected(&self) -> error::Result<bool>;

    /// MediaCompatibility property
    #[zbus(property)]
    fn media_compatibility(&self) -> error::Result<Vec<MediaCompatibility>>;

    /// MediaRemovable property
    #[zbus(property)]
    fn media_removable(&self) -> error::Result<bool>;

    /// Model property
    #[zbus(property)]
    fn model(&self) -> error::Result<String>;

    /// Optical property
    #[zbus(property)]
    fn optical(&self) -> error::Result<bool>;

    /// OpticalBlank property
    #[zbus(property)]
    fn optical_blank(&self) -> error::Result<bool>;

    /// OpticalNumAudioTracks property
    #[zbus(property)]
    fn optical_num_audio_tracks(&self) -> error::Result<u32>;

    /// OpticalNumDataTracks property
    #[zbus(property)]
    fn optical_num_data_tracks(&self) -> error::Result<u32>;

    /// OpticalNumSessions property
    #[zbus(property)]
    fn optical_num_sessions(&self) -> error::Result<u32>;

    /// OpticalNumTracks property
    #[zbus(property)]
    fn optical_num_tracks(&self) -> error::Result<u32>;

    /// Removable property
    #[zbus(property)]
    fn removable(&self) -> error::Result<bool>;

    /// Revision property
    #[zbus(property)]
    fn revision(&self) -> error::Result<String>;

    /// Rotational rate of the drive.
    #[zbus(property)]
    fn rotation_rate(&self) -> error::Result<RotationRate>;

    /// Seat property
    #[zbus(property)]
    fn seat(&self) -> error::Result<String>;

    /// Serial property
    #[zbus(property)]
    fn serial(&self) -> error::Result<String>;

    /// SiblingId property
    #[zbus(property)]
    fn sibling_id(&self) -> error::Result<String>;

    /// Size property
    #[zbus(property)]
    fn size(&self) -> error::Result<u64>;

    /// SortKey property
    #[zbus(property)]
    fn sort_key(&self) -> error::Result<String>;

    /// TimeDetected property
    #[zbus(property)]
    fn time_detected(&self) -> error::Result<u64>;

    /// TimeMediaDetected property
    #[zbus(property)]
    fn time_media_detected(&self) -> error::Result<u64>;

    /// Vendor property
    #[zbus(property)]
    fn vendor(&self) -> error::Result<String>;

    /// WWN property
    #[zbus(property, name = "WWN")]
    fn wwn(&self) -> error::Result<String>;
}
